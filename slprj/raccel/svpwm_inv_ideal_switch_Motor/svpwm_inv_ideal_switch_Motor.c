#include "svpwm_inv_ideal_switch_Motor.h"
#include "rtwtypes.h"
#include <stdlib.h>
#include "svpwm_inv_ideal_switch_Motor_types.h"
#include "mwmathutil.h"
#include <string.h>
#include <stddef.h>
#include "svpwm_inv_ideal_switch_Motor_private.h"
#include "rt_logging_mmi.h"
#include "svpwm_inv_ideal_switch_Motor_capi.h"
#include "svpwm_inv_ideal_switch_Motor_dt.h"
extern void * CreateDiagnosticAsVoidPtr_wrapper ( const char * id , int nargs
, ... ) ; RTWExtModeInfo * gblRTWExtModeInfo = NULL ; void
raccelForceExtModeShutdown ( boolean_T extModeStartPktReceived ) { if ( !
extModeStartPktReceived ) { boolean_T stopRequested = false ;
rtExtModeWaitForStartPkt ( gblRTWExtModeInfo , 6 , & stopRequested ) ; }
rtExtModeShutdown ( 6 ) ; }
#include "slsv_diagnostic_codegen_c_api.h"
#include "slsa_engine_exec.h"
#ifdef RSIM_WITH_SOLVER_MULTITASKING
boolean_T gbl_raccel_isMultitasking = 1 ;
#else
boolean_T gbl_raccel_isMultitasking = 0 ;
#endif
boolean_T gbl_raccel_tid01eq = 0 ; int_T gbl_raccel_NumST = 7 ; const char_T
* gbl_raccel_Version = "25.1 (R2025a) 21-Nov-2024" ; void
raccel_setup_MMIStateLog ( SimStruct * S ) {
#ifdef UseMMIDataLogging
rt_FillStateSigInfoFromMMI ( ssGetRTWLogInfo ( S ) , & ssGetErrorStatus ( S )
) ;
#else
UNUSED_PARAMETER ( S ) ;
#endif
} static DataMapInfo rt_dataMapInfo ; DataMapInfo * rt_dataMapInfoPtr = &
rt_dataMapInfo ; rtwCAPI_ModelMappingInfo * rt_modelMapInfoPtr = & ( rt_dataMapInfo . mmi ) ; int_T enableFcnCallFlag [ ] = { 1 , 1 , 1 , 1 , 1 , 1 , 1 } ; const char * raccelLoadInputsAndAperiodicHitTimes ( SimStruct * S , const char * inportFileName , int * matFileFormat ) { return rt_RAccelReadInportsMatFile ( S , inportFileName , matFileFormat ) ; }
#include "simstruc.h"
#include "fixedpoint.h"
#include "slsa_engine_exec.h"
#include "simtarget/slSimTgtSLExecSimBridge.h"
#define kzdynaaz2j (-1)
B rtB ; X rtX ; DW rtDW ; PrevZCX rtPrevZCX ; MassMatrix rtMassMatrix ;
static SimStruct model_S ; SimStruct * const rtS = & model_S ; real_T
rt_TDelayInterpolate ( real_T tMinusDelay , real_T tStart , real_T * uBuf ,
int_T bufSz , int_T * lastIdx , int_T oldestIdx , int_T newIdx , real_T
initOutput , boolean_T discrete , boolean_T minorStepAndTAtLastMajorOutput )
{ int_T i ; real_T yout , t1 , t2 , u1 , u2 ; real_T * tBuf = uBuf + bufSz ;
if ( ( newIdx == 0 ) && ( oldestIdx == 0 ) && ( tMinusDelay > tStart ) )
return initOutput ; if ( tMinusDelay <= tStart ) return initOutput ; if ( ( tMinusDelay <= tBuf [ oldestIdx ] ) ) { if ( discrete ) { return ( uBuf [ oldestIdx ] ) ; } else { int_T tempIdx = oldestIdx + 1 ; if ( oldestIdx == bufSz - 1 ) tempIdx = 0 ; t1 = tBuf [ oldestIdx ] ; t2 = tBuf [ tempIdx ] ; u1 = uBuf [ oldestIdx ] ; u2 = uBuf [ tempIdx ] ; if ( t2 == t1 ) { if ( tMinusDelay >= t2 ) { yout = u2 ; } else { yout = u1 ; } } else { real_T f1 = ( t2 - tMinusDelay ) / ( t2 - t1 ) ; real_T f2 = 1.0 - f1 ; yout = f1 * u1 + f2 * u2 ; } return yout ; } } if ( minorStepAndTAtLastMajorOutput ) { if ( newIdx != 0 ) { if ( * lastIdx == newIdx ) { ( * lastIdx ) -- ; } newIdx -- ; } else { if ( * lastIdx == newIdx ) { * lastIdx = bufSz - 1 ; } newIdx = bufSz - 1 ; } } i = * lastIdx ; if ( tBuf [ i ] < tMinusDelay ) { while ( tBuf [ i ] < tMinusDelay ) { if ( i == newIdx ) break ; i = ( i < ( bufSz - 1 ) ) ? ( i + 1 ) : 0 ; } } else { while ( tBuf [ i ] >= tMinusDelay ) { i = ( i > 0 ) ? i - 1 : ( bufSz - 1 ) ; } i = ( i < ( bufSz - 1 ) ) ? ( i + 1 ) : 0 ; } * lastIdx = i ; if ( discrete ) { double tempEps = ( DBL_EPSILON ) * 128.0 ; double localEps = tempEps * muDoubleScalarAbs ( tBuf [ i ] ) ; if ( tempEps > localEps ) { localEps = tempEps ; } localEps = localEps / 2.0 ; if ( tMinusDelay >= ( tBuf [ i ] - localEps ) ) { yout = uBuf [ i ] ; } else { if ( i == 0 ) { yout = uBuf [ bufSz - 1 ] ; } else { yout = uBuf [ i - 1 ] ; } } } else { if ( i == 0 ) { t1 = tBuf [ bufSz - 1 ] ; u1 = uBuf [ bufSz - 1 ] ; } else { t1 = tBuf [ i - 1 ] ; u1 = uBuf [ i - 1 ] ; } t2 = tBuf [ i ] ; u2 = uBuf [ i ] ; if ( t2 == t1 ) { if ( tMinusDelay >= t2 ) { yout = u2 ; } else { yout = u1 ; } } else { real_T f1 = ( t2 - tMinusDelay ) / ( t2 - t1 ) ; real_T f2 = 1.0 - f1 ; yout = f1 * u1 + f2 * u2 ; } } return ( yout ) ; } boolean_T rt_TDelayUpdateTailOrGrowBuf ( int32_T * bufSzPtr , int32_T * tailPtr , int32_T * headPtr , int32_T * lastPtr , real_T tMinusDelay , real_T * * uBufPtr , boolean_T isfixedbuf , boolean_T istransportdelay , int32_T * maxNewBufSzPtr ) { real_T * tBuf ; real_T * tempU ; real_T * tempX ; real_T * uBuf ; real_T * xBuf ; int32_T bufSz ; int32_T numBuffer ; int32_T tail ; int32_T testIdx ; boolean_T success ; success = true ; tail = * tailPtr ; bufSz = * bufSzPtr ; tBuf = & ( * uBufPtr ) [ bufSz ] ; xBuf = NULL ; if ( istransportdelay ) { numBuffer = 3 ; xBuf = & ( * uBufPtr ) [ bufSz << 1 ] ; } else { numBuffer = 2 ; } if ( tail < bufSz - 1 ) { testIdx = tail + 1 ; } else { testIdx = 0 ; } if ( ( tMinusDelay <= tBuf [ testIdx ] ) && ( ! isfixedbuf ) ) { tempX = NULL ; uBuf = * uBufPtr ; if ( bufSz + 1024 > * maxNewBufSzPtr ) { * maxNewBufSzPtr = bufSz + 1024 ; } tempU = ( real_T * ) malloc ( ( uint32_T ) ( ( ( bufSz + 1024 ) * numBuffer ) << 3 ) ) ; if ( tempU == NULL ) { success = false ; } else { if ( istransportdelay ) { tempX = & tempU [ ( bufSz + 1024 ) + ( bufSz + 1024 ) ] ; } for ( numBuffer = tail ; numBuffer < bufSz ; numBuffer ++ ) { tempU [ ( bufSz + 1024 ) + ( numBuffer - tail ) ] = tBuf [ numBuffer ] ; tempU [ numBuffer - tail ] = uBuf [ numBuffer ] ; if ( istransportdelay ) { tempX [ numBuffer - tail ] = xBuf [ numBuffer ] ; } } for ( numBuffer = 0 ; numBuffer <= tail ; numBuffer ++ ) { tempU [ ( bufSz + 1024 ) + ( ( numBuffer + bufSz ) - tail ) ] = tBuf [ numBuffer ] ; tempU [ ( numBuffer + bufSz ) - tail ] = uBuf [ numBuffer ] ; if ( istransportdelay ) { tempX [ ( numBuffer + bufSz ) - tail ] = xBuf [ numBuffer ] ; } } if ( * lastPtr > tail ) { * lastPtr -= tail ; } else { * lastPtr += bufSz - tail ; } * tailPtr = 0 ; * headPtr = bufSz ; free ( uBuf ) ; * bufSzPtr = bufSz + 1024 ; * uBufPtr = tempU ; } } else { * tailPtr = testIdx ; } return success ; } real_T look1_binlxpw ( real_T u0 , const real_T bp0 [ ] , const real_T table [ ] , uint32_T maxIndex ) { real_T frac ; real_T yL_0d0 ; uint32_T bpIdx ; uint32_T iLeft ; uint32_T iRght ; if ( u0 <= bp0 [ 0U ] ) { iLeft = 0U ; frac = ( u0 - bp0 [ 0U ] ) / ( bp0 [ 1U ] - bp0 [ 0U ] ) ; } else if ( u0 < bp0 [ maxIndex ] ) { bpIdx = maxIndex >> 1U ; iLeft = 0U ; iRght = maxIndex ; while ( iRght - iLeft > 1U ) { if ( u0 < bp0 [ bpIdx ] ) { iRght = bpIdx ; } else { iLeft = bpIdx ; } bpIdx = ( iRght + iLeft ) >> 1U ; } frac = ( u0 - bp0 [ iLeft ] ) / ( bp0 [ iLeft + 1U ] - bp0 [ iLeft ] ) ; } else { iLeft = maxIndex - 1U ; frac = ( u0 - bp0 [ maxIndex - 1U ] ) / ( bp0 [ maxIndex ] - bp0 [ maxIndex - 1U ] ) ; } yL_0d0 = table [ iLeft ] ; return ( table [ iLeft + 1U ] - yL_0d0 ) * frac + yL_0d0 ; } void MdlInitialize ( void ) { int_T is ; int_T tmp_e ; int_T tmp_g ; int_T tmp_i ; int_T tmp_j ; int_T tmp_m ; boolean_T tmp ; boolean_T tmp_p ; SimStruct * S ; void * diag ; rtX . mmcyaey4zw = 0.0 ; rtDW . fvjpifmnqp [ 0 ] = rtP . UnitDelay2_InitialCondition ; rtDW . fvjpifmnqp [ 1 ] = rtP . UnitDelay2_InitialCondition ; rtDW . fvjpifmnqp [ 2 ] = rtP . UnitDelay2_InitialCondition ; rtDW . afz1wmfwwl = rtB . knjptrjfxw ; rtDW . l311fk1wdw = rtB . iixyxlabma ; rtDW . okewh4umdj = rtB . lbfipievkr ; rtDW . pzb0hgihqm = rtB . amgg2aweyl ; rtDW . liqja2sob3 = rtB . f2c4mvklul ; rtDW . inzd25bki4 = rtB . hxwhc32bo0 ; tmp = false ; tmp_p = false ; if ( tmp_p || tmp ) { is = strcmp ( ssGetSolverName ( rtS ) , "daessc" ) ; tmp_e = strcmp ( ssGetSolverName ( rtS ) , "ode14x" ) ; tmp_i = strcmp ( ssGetSolverName ( rtS ) , "ode15s" ) ; tmp_m = strcmp ( ssGetSolverName ( rtS ) , "ode1be" ) ; tmp_g = strcmp ( ssGetSolverName ( rtS ) , "ode23t" ) ; tmp_j = strcmp ( ssGetSolverName ( rtS ) , "odeN" ) ; if ( ( boolean_T ) ( ( is != 0 ) & ( tmp_e != 0 ) & ( tmp_i != 0 ) & ( tmp_m != 0 ) & ( tmp_g != 0 ) & ( tmp_j != 0 ) ) ) { S = rtS ; diag = CreateDiagnosticAsVoidPtr ( "SL_SERVICES:utils:CODEGEN_MSG_WITH_FALLBACK" , 4 , 3 , "\"Detected inconsistent solvers in the model reference hierarchy. Model built with daessc requires one of {daessc, ode14x, ode15s, ode1be, ode23t, odeN} solvers to run. Use one of the required solvers in the top model.\"" , 3 , "physmod:simscape:engine:sli:SimscapeExecutionBlock:InconsistentSolversInModelRef" , 3 , "daessc" , 3 , "{daessc, ode14x, ode15s, ode1be, ode23t, odeN}" ) ; rt_ssSet_slErrMsg ( S , diag ) ; } } rtDW . mgelhzivq0 [ 0 ] = 29U ; rtDW . mgelhzivq0 [ 1 ] = 29U ; rtDW . mgelhzivq0 [ 2 ] = 29U ; rtDW . mgelhzivq0 [ 3 ] = 29U ; rtDW . mgelhzivq0 [ 4 ] = 29U ; rtDW . mgelhzivq0 [ 5 ] = 29U ; rtDW . mgelhzivq0 [ 6 ] = 29U ; rtDW . mgelhzivq0 [ 7 ] = 29U ; rtDW . mgelhzivq0 [ 8 ] = 29U ; rtDW . mgelhzivq0 [ 9 ] = 29U ; rtDW . mgelhzivq0 [ 10 ] = 29U ; rtDW . mgelhzivq0 [ 11 ] = 29U ; rtDW . mgelhzivq0 [ 12 ] = 29U ; rtDW . mgelhzivq0 [ 13 ] = 29U ; rtDW . mgelhzivq0 [ 14 ] = 29U ; rtDW . mgelhzivq0 [ 15 ] = 29U ; rtDW . mgelhzivq0 [ 16 ] = 29U ; rtDW . mgelhzivq0 [ 17 ] = 29U ; rtDW . mgelhzivq0 [ 18 ] = 29U ; rtDW . mgelhzivq0 [ 19 ] = 29U ; rtDW . mgelhzivq0 [ 20 ] = 29U ; rtDW . mgelhzivq0 [ 21 ] = 29U ; rtDW . mgelhzivq0 [ 22 ] = 29U ; rtDW . mgelhzivq0 [ 23 ] = 29U ; rtDW . mgelhzivq0 [ 24 ] = 29U ; rtDW . mgelhzivq0 [ 25 ] = 29U ; rtDW . mgelhzivq0 [ 26 ] = 29U ; rtDW . mgelhzivq0 [ 27 ] = 29U ; rtDW . mgelhzivq0 [ 28 ] = 29U ; rtDW . mgelhzivq0 [ 29 ] = 29U ; rtDW . mgelhzivq0 [ 30 ] = 29U ; rtDW . mgelhzivq0 [ 31 ] = 29U ; rtDW . mgelhzivq0 [ 32 ] = 29U ; rtDW . mgelhzivq0 [ 33 ] = 29U ; rtDW . mgelhzivq0 [ 34 ] = 29U ; rtDW . mgelhzivq0 [ 35 ] = 29U ; rtDW . mgelhzivq0 [ 36 ] = 29U ; rtDW . mgelhzivq0 [ 37 ] = 29U ; rtDW . mgelhzivq0 [ 38 ] = 29U ; rtDW . mgelhzivq0 [ 39 ] = 29U ; rtDW . mgelhzivq0 [ 40 ] = 29U ; rtDW . mgelhzivq0 [ 41 ] = 29U ; rtDW . mgelhzivq0 [ 42 ] = 29U ; rtDW . mgelhzivq0 [ 43 ] = 29U ; rtDW . mgelhzivq0 [ 44 ] = 29U ; rtDW . mgelhzivq0 [ 45 ] = 29U ; rtDW . mgelhzivq0 [ 46 ] = 29U ; rtDW . mgelhzivq0 [ 47 ] = 29U ; rtDW . mgelhzivq0 [ 48 ] = 29U ; rtDW . mgelhzivq0 [ 49 ] = 29U ; rtDW . mgelhzivq0 [ 50 ] = 29U ; rtDW . mgelhzivq0 [ 51 ] = 29U ; rtDW . mgelhzivq0 [ 52 ] = 29U ; rtDW . mgelhzivq0 [ 53 ] = 29U ; rtDW . mgelhzivq0 [ 54 ] = 29U ; rtDW . mgelhzivq0 [ 55 ] = 29U ; rtX . lqcuiwaata = 0.0 ; rtX . fqujvrhmxc = 0.0 ; rtX . lvqvgep4z3 = 0.0 ; rtX . c1dvebixah = rtP . integrator_IC ; rtDW . fvqqusvlbd = rtP . Memory_InitialCondition ; rtX . bufufyp5jw = rtP . integrator_IC_ldmkngjmod ; rtDW . ch151dnkqe = rtP . Memory_InitialCondition_ea2pbevdn4 ; rtX . nrr4jufios = rtP . integrator_IC_mzomdehgl0 ; rtDW . imtaqygzf4 = rtP . Memory_InitialCondition_noummn3k0p ; rtX . adzjcfmnhs = 0.0 ; rtDW . myxkp4g3jb = rtP . PIDController2_InitialConditionForIntegrator ; rtDW . cgbt3rljof = false ; rtDW . an2k1o2b34 = 0.0 ; rtDW . ll5n1f2emr = true ; rtDW . czk0zyr4wh = 0.0 ; rtDW . ltlrw2hvbj = true ; rtDW . e0jxwlk51j = 0.0 ; rtDW . pf125dsvmu = true ; rtDW . lohwd1ejop = 0.0 ; rtDW . abosh0vgit = true ; rtDW . mimt35h5ox = kzdynaaz2j ; rtDW . gcyhq2afeb = rtP . PIDController3_InitialConditionForIntegrator ; rtDW . p4cmclm0n5 = rtP . PIDController4_InitialConditionForIntegrator ; rtDW . jmydjkcywd = 0.0 ; rtDW . j1n4b2y2es = true ; rtDW . b4jd5d00a5 = kzdynaaz2j ; { static int_T modelMassMatrixIr [ 16 ] = { 0 , 1 , 4 , 2 , 5 , 3 , 6 , 7 , 8 , 38 , 39 , 40 , 41 , 42 , 43 , 44 } ; static int_T modelMassMatrixJc [ 46 ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 } ; static real_T modelMassMatrixPr [ 16 ] = { 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 , 1.0 } ; ( void ) memcpy ( rtMassMatrix . ir , modelMassMatrixIr , 16 * sizeof ( int_T ) ) ; ( void ) memcpy ( rtMassMatrix . jc , modelMassMatrixJc , 46 * sizeof ( int_T ) ) ; ( void ) memcpy ( rtMassMatrix . pr , modelMassMatrixPr , 16 * sizeof ( real_T ) ) ; } } void MdlStart ( void ) { CXPtMax * _rtXPerturbMax ; CXPtMin * _rtXPerturbMin ; NeModelParameters modelParameters ; NeModelParameters modelParameters_p ; NeslRtpManager * manager ; NeslRtpManager * manager_p ; NeslSimulationData * simulationData ; NeslSimulator * tmp_p ; NeuDiagnosticManager * diagnosticManager ; NeuDiagnosticTree * diagnosticTree ; NeuDiagnosticTree * diagnosticTree_e ; NeuDiagnosticTree * diagnosticTree_p ; char * msg ; char * msg_e ; char * msg_p ; real_T tmp_i [ 16 ] ; real_T time ; real_T tmp_e ; int_T tmp_m [ 5 ] ; int_T i ; boolean_T tmp ; boolean_T val ; { bool externalInputIsInDatasetFormat = false ; void * pISigstreamManager = rt_GetISigstreamManager ( rtS ) ; rtwISigstreamManagerGetInputIsInDatasetFormat ( pISigstreamManager , & externalInputIsInDatasetFormat ) ; if ( externalInputIsInDatasetFormat ) { } } _rtXPerturbMax = ( ( CXPtMax * ) ssGetJacobianPerturbationBoundsMaxVec ( rtS ) ) ; _rtXPerturbMin = ( ( CXPtMin * ) ssGetJacobianPerturbationBoundsMinVec ( rtS ) ) ; rtB . mtks2gpnub [ 0 ] = rtP . UnitDelay2_InitialCondition ; rtB . mtks2gpnub [ 1 ] = rtP . UnitDelay2_InitialCondition ; rtB . mtks2gpnub [ 2 ] = rtP . UnitDelay2_InitialCondition ; rtB . hhp3y0oygr [ 0 ] = 1.0E-9 ; rtB . hhp3y0oygr [ 1 ] = 0.0 ; rtB . knjptrjfxw = rtP . IntegratorwithWrappedStateDiscreteorContinuous_x0 ; rtDW . ohmbboa034 = true ; rtB . iixyxlabma = rtP . PWMGenerator1_Tdelay ; rtDW . lzwswludg5 = true ; rtB . ec040fp0fa [ 0 ] = 1.0E-9 ; rtB . ec040fp0fa [ 1 ] = 0.0 ; rtB . lbfipievkr = rtP . IntegratorwithWrappedStateDiscreteorContinuous_x0_jmi4gwmvri ; rtDW . ee03va2m5d = true ; rtB . amgg2aweyl = rtP . PWMGenerator2_Tdelay ; rtDW . lm2wj3hxgc = true ; rtB . nysfdpoprp [ 0 ] = 1.0E-9 ; rtB . nysfdpoprp [ 1 ] = 0.0 ; rtB . f2c4mvklul = rtP . IntegratorwithWrappedStateDiscreteorContinuous_x0_cmhchouter ; rtDW . pstpl3h2q2 = true ; rtB . hxwhc32bo0 = rtP . PWMGenerator_Tdelay ; rtDW . nojfuzuk1p = true ; manager_p = nesl_lease_rtp_manager ( "svpwm_inv_ideal_switch_Motor/Solver Configuration1_1" , 0 ) ; manager = manager_p ; tmp = pointer_is_null ( manager_p ) ; if ( tmp ) { svpwm_inv_ideal_switch_Motor_128b9dc4_1_gateway ( ) ; manager = nesl_lease_rtp_manager ( "svpwm_inv_ideal_switch_Motor/Solver Configuration1_1" , 0 ) ; } rtDW . ofz4qubiel = ( void * ) manager ; rtDW . edfgpbf04f = true ; tmp_p = nesl_lease_simulator ( "svpwm_inv_ideal_switch_Motor/Solver Configuration1_1" , 0 , 0 ) ; rtDW . et4usql3vc = ( void * ) tmp_p ; tmp = pointer_is_null ( rtDW . et4usql3vc ) ; if ( tmp ) { svpwm_inv_ideal_switch_Motor_128b9dc4_1_gateway ( ) ; tmp_p = nesl_lease_simulator ( "svpwm_inv_ideal_switch_Motor/Solver Configuration1_1" , 0 , 0 ) ; rtDW . et4usql3vc = ( void * ) tmp_p ; } slsaSaveRawMemoryForSimTargetOP ( rtS , "svpwm_inv_ideal_switch_Motor/Solver Configuration1_100" , ( void * * ) ( & rtDW . et4usql3vc ) , ( 0U ) * sizeof ( real_T ) , nesl_save_simdata , nesl_restore_simdata ) ; simulationData = nesl_create_simulation_data ( ) ; rtDW . mjaqu4jcnj = ( void * ) simulationData ; diagnosticManager = rtw_create_diagnostics ( ) ; rtDW . lt4h1wfkog = ( void * ) diagnosticManager ; modelParameters . mSolverType = NE_SOLVER_TYPE_DAE ; modelParameters . mSolverTolerance = 0.001 ; modelParameters . mSolverAbsTol = 0.001 ; modelParameters . mSolverRelTol = 0.001 ; modelParameters . mVariableStepSolver = true ; modelParameters . mIsUsingODEN = false ; modelParameters . mSolverModifyAbsTol = NE_MODIFY_ABS_TOL_YES ; modelParameters . mFixedStepSize = 0.001 ; modelParameters . mStartTime = 0.0 ; modelParameters . mLoadInitialState = false ; modelParameters . mUseSimState = false ; modelParameters . mLinTrimCompile = false ; modelParameters . mLoggingMode = SSC_LOGGING_OFF ; modelParameters . mRTWModifiedTimeStamp = 6.85045521E+8 ; modelParameters . mZcDisabled = false ; modelParameters . mUseModelRefSolver = false ; modelParameters . mTargetFPGAHIL = false ; tmp_e = 0.001 ; modelParameters . mSolverTolerance = tmp_e ; tmp_e = 0.0 ; modelParameters . mFixedStepSize = tmp_e ; tmp = true ; modelParameters . mVariableStepSolver = tmp ; tmp = false ; modelParameters . mIsUsingODEN = tmp ; tmp = slIsRapidAcceleratorSimulating ( ) ; val = ssGetGlobalInitialStatesAvailable ( rtS ) ; if ( tmp ) { val = ( val && ssIsFirstInitCond ( rtS ) ) ; } modelParameters . mLoadInitialState = val ; modelParameters . mZcDisabled = false ; diagnosticManager = ( NeuDiagnosticManager * ) rtDW . lt4h1wfkog ; diagnosticTree = neu_diagnostic_manager_get_initial_tree ( diagnosticManager ) ; i = nesl_initialize_simulator ( ( NeslSimulator * ) rtDW . et4usql3vc , & modelParameters , diagnosticManager ) ; if ( i != 0 ) { tmp = error_buffer_is_empty ( ssGetErrorStatus ( rtS ) ) ; if ( tmp ) { msg = rtw_diagnostics_msg ( diagnosticTree ) ; ssSetErrorStatus ( rtS , msg ) ; } } simulationData = ( NeslSimulationData * ) rtDW . mjaqu4jcnj ; time = ssGetT ( rtS ) ; simulationData -> mData -> mTime . mN = 1 ; simulationData -> mData -> mTime . mX = & time ; simulationData -> mData -> mContStates . mN = 36 ; simulationData -> mData -> mContStates . mX = & rtX . mmg5sph3io [ 0 ] ; simulationData -> mData -> mDiscStates . mN = 147 ; simulationData -> mData -> mDiscStates . mX = & rtDW . atond0rmxa [ 0 ] ; simulationData -> mData -> mModeVector . mN = 56 ; simulationData -> mData -> mModeVector . mX = & rtDW . c1wtxhepbi [ 0 ] ; tmp = ( ssIsMajorTimeStep ( rtS ) && ssGetRTWSolverInfo ( rtS ) -> foundContZcEvents ) ; simulationData -> mData -> mFoundZcEvents = tmp ; simulationData -> mData -> mHadEvents = false ; simulationData -> mData -> mIsMajorTimeStep = ssIsMajorTimeStep ( rtS ) ; tmp = ( ssGetMdlInfoPtr ( rtS ) -> mdlFlags . solverAssertCheck == 1U ) ; simulationData -> mData -> mIsSolverAssertCheck = tmp ; tmp = ssIsSolverCheckingCIC ( rtS ) ; simulationData -> mData -> mIsSolverCheckingCIC = tmp ; tmp = ssIsSolverComputingJacobian ( rtS ) ; simulationData -> mData -> mIsComputingJacobian = tmp ; simulationData -> mData -> mIsEvaluatingF0 = ( ssGetEvaluatingF0ForJacobian ( rtS ) != 0 ) ; tmp = ssIsSolverRequestingReset ( rtS ) ; simulationData -> mData -> mIsSolverRequestingReset = tmp ; simulationData -> mData -> mIsModeUpdateTimeStep = ssIsModeUpdateTimeStep ( rtS ) ; tmp_m [ 0 ] = 0 ; tmp_i [ 0 ] = rtB . m1glkuwbva [ 0 ] ; tmp_i [ 1 ] = rtB . m1glkuwbva [ 1 ] ; tmp_i [ 2 ] = rtB . m1glkuwbva [ 2 ] ; tmp_i [ 3 ] = rtB . m1glkuwbva [ 3 ] ; tmp_m [ 1 ] = 4 ; tmp_i [ 4 ] = rtB . ipcfdxqbvr [ 0 ] ; tmp_i [ 5 ] = rtB . ipcfdxqbvr [ 1 ] ; tmp_i [ 6 ] = rtB . ipcfdxqbvr [ 2 ] ; tmp_i [ 7 ] = rtB . ipcfdxqbvr [ 3 ] ; tmp_m [ 2 ] = 8 ; tmp_i [ 8 ] = rtB . mpqyczxej3 [ 0 ] ; tmp_i [ 9 ] = rtB . mpqyczxej3 [ 1 ] ; tmp_i [ 10 ] = rtB . mpqyczxej3 [ 2 ] ; tmp_i [ 11 ] = rtB . mpqyczxej3 [ 3 ] ; tmp_m [ 3 ] = 12 ; tmp_i [ 12 ] = rtB . embqhexp1p [ 0 ] ; tmp_i [ 13 ] = rtB . embqhexp1p [ 1 ] ; tmp_i [ 14 ] = rtB . embqhexp1p [ 2 ] ; tmp_i [ 15 ] = rtB . embqhexp1p [ 3 ] ; tmp_m [ 4 ] = 16 ; simulationData -> mData -> mInputValues . mN = 16 ; simulationData -> mData -> mInputValues . mX = & tmp_i [ 0 ] ; simulationData -> mData -> mInputOffsets . mN = 5 ; simulationData -> mData -> mInputOffsets . mX = & tmp_m [ 0 ] ; simulationData -> mData -> mNumjacDxLo . mN = 36 ; simulationData -> mData -> mNumjacDxLo . mX = & _rtXPerturbMin -> mmg5sph3io [ 0 ] ; simulationData -> mData -> mNumjacDxHi . mN = 36 ; simulationData -> mData -> mNumjacDxHi . mX = & _rtXPerturbMax -> mmg5sph3io [ 0 ] ; diagnosticManager = ( NeuDiagnosticManager * ) rtDW . lt4h1wfkog ; diagnosticTree_p = neu_diagnostic_manager_get_initial_tree ( diagnosticManager ) ; i = ne_simulator_method ( ( NeslSimulator * ) rtDW . et4usql3vc , NESL_SIM_NUMJAC_DX_BOUNDS , simulationData , diagnosticManager ) ; if ( i != 0 ) { tmp = error_buffer_is_empty ( ssGetErrorStatus ( rtS ) ) ; if ( tmp ) { msg_p = rtw_diagnostics_msg ( diagnosticTree_p ) ; ssSetErrorStatus ( rtS , msg_p ) ; } } tmp_p = nesl_lease_simulator ( "svpwm_inv_ideal_switch_Motor/Solver Configuration1_1" , 1 , 0 ) ; rtDW . e45uxvk1lw = ( void * ) tmp_p ; tmp = pointer_is_null ( rtDW . e45uxvk1lw ) ; if ( tmp ) { svpwm_inv_ideal_switch_Motor_128b9dc4_1_gateway ( ) ; tmp_p = nesl_lease_simulator ( "svpwm_inv_ideal_switch_Motor/Solver Configuration1_1" , 1 , 0 ) ; rtDW . e45uxvk1lw = ( void * ) tmp_p ; } slsaSaveRawMemoryForSimTargetOP ( rtS , "svpwm_inv_ideal_switch_Motor/Solver Configuration1_110" , ( void * * ) ( & rtDW . e45uxvk1lw ) , ( 0U ) * sizeof ( real_T ) , nesl_save_simdata , nesl_restore_simdata ) ; simulationData = nesl_create_simulation_data ( ) ; rtDW . oxh0jmsh2a = ( void * ) simulationData ; diagnosticManager = rtw_create_diagnostics ( ) ; rtDW . h3xczpc1e2 = ( void * ) diagnosticManager ; modelParameters_p . mSolverType = NE_SOLVER_TYPE_DAE ; modelParameters_p . mSolverTolerance = 0.001 ; modelParameters_p . mSolverAbsTol = 0.001 ; modelParameters_p . mSolverRelTol = 0.001 ; modelParameters_p . mVariableStepSolver = true ; modelParameters_p . mIsUsingODEN = false ; modelParameters_p . mSolverModifyAbsTol = NE_MODIFY_ABS_TOL_YES ; modelParameters_p . mFixedStepSize = 0.001 ; modelParameters_p . mStartTime = 0.0 ; modelParameters_p . mLoadInitialState = false ; modelParameters_p . mUseSimState = false ; modelParameters_p . mLinTrimCompile = false ; modelParameters_p . mLoggingMode = SSC_LOGGING_OFF ; modelParameters_p . mRTWModifiedTimeStamp = 6.85045521E+8 ; modelParameters_p . mZcDisabled = false ; modelParameters_p . mUseModelRefSolver = false ; modelParameters_p . mTargetFPGAHIL = false ; tmp_e = 0.001 ; modelParameters_p . mSolverTolerance = tmp_e ; tmp_e = 0.0 ; modelParameters_p . mFixedStepSize = tmp_e ; tmp = true ; modelParameters_p . mVariableStepSolver = tmp ; tmp = false ; modelParameters_p . mIsUsingODEN = tmp ; tmp = slIsRapidAcceleratorSimulating ( ) ; val = ssGetGlobalInitialStatesAvailable ( rtS ) ; if ( tmp ) { val = ( val && ssIsFirstInitCond ( rtS ) ) ; } modelParameters_p . mLoadInitialState = val ; modelParameters_p . mZcDisabled = false ; diagnosticManager = ( NeuDiagnosticManager * ) rtDW . h3xczpc1e2 ; diagnosticTree_e = neu_diagnostic_manager_get_initial_tree ( diagnosticManager ) ; i = nesl_initialize_simulator ( ( NeslSimulator * ) rtDW . e45uxvk1lw , & modelParameters_p , diagnosticManager ) ; if ( i != 0 ) { tmp = error_buffer_is_empty ( ssGetErrorStatus ( rtS ) ) ; if ( tmp ) { msg_e = rtw_diagnostics_msg ( diagnosticTree_e ) ; ssSetErrorStatus ( rtS , msg_e ) ; } } rtDW . apb44q1alb = 0.0 ; rtDW . pgnkj0dpye [ 0 ] = 0 ; rtDW . pgnkj0dpye [ 1 ] = 0 ; rtDW . pgnkj0dpye [ 2 ] = 0 ; rtDW . pgnkj0dpye [ 3 ] = 8192 ; rtDW . lhset4od0v [ 0 ] = ( real_T * ) malloc ( ( uint32_T ) ( ( rtDW . pgnkj0dpye [ 3 ] << 1 ) * ( int32_T ) sizeof ( real_T ) ) ) ; ( ( real_T * ) rtDW . lhset4od0v [ 0 ] ) [ 0 ] = rtP . TransportDelay_InitOutput ; ( ( real_T * ) rtDW . lhset4od0v [ 0 ] ) [ rtDW . pgnkj0dpye [ 3 ] ] = ssGetT ( rtS ) ; slsaSaveRawMemoryForSimTargetOP ( rtS , "svpwm_inv_ideal_switch_Motor/CurrentsMuxFilter1/Mean2/Model/Transport Delay0" , ( void * * ) ( & rtDW . lhset4od0v [ 0 ] ) , ( rtDW . pgnkj0dpye [ 3 ] << 1 ) * sizeof ( real_T ) , NULL , NULL ) ; rtDW . lj0scfk3vh = 0.0 ; rtDW . lf1hqp3kgd [ 0 ] = 0 ; rtDW . lf1hqp3kgd [ 1 ] = 0 ; rtDW . lf1hqp3kgd [ 2 ] = 0 ; rtDW . lf1hqp3kgd [ 3 ] = 8192 ; rtDW . htnluil54k [ 0 ] = ( real_T * ) malloc ( ( uint32_T ) ( ( rtDW . lf1hqp3kgd [ 3 ] << 1 ) * ( int32_T ) sizeof ( real_T ) ) ) ; ( ( real_T * ) rtDW . htnluil54k [ 0 ] ) [ 0 ] = rtP . TransportDelay_InitOutput_mvnxyosv3m ; ( ( real_T * ) rtDW . htnluil54k [ 0 ] ) [ rtDW . lf1hqp3kgd [ 3 ] ] = ssGetT ( rtS ) ; slsaSaveRawMemoryForSimTargetOP ( rtS , "svpwm_inv_ideal_switch_Motor/CurrentsMuxFilter1/Mean1/Model/Transport Delay0" , ( void * * ) ( & rtDW . htnluil54k [ 0 ] ) , ( rtDW . lf1hqp3kgd [ 3 ] << 1 ) * sizeof ( real_T ) , NULL , NULL ) ; rtDW . b2c3cqi0k1 = 0.0 ; rtDW . asfvwsoqaf [ 0 ] = 0 ; rtDW . asfvwsoqaf [ 1 ] = 0 ; rtDW . asfvwsoqaf [ 2 ] = 0 ; rtDW . asfvwsoqaf [ 3 ] = 8192 ; rtDW . bayevhew2y [ 0 ] = ( real_T * ) malloc ( ( uint32_T ) ( ( rtDW . asfvwsoqaf [ 3 ] << 1 ) * ( int32_T ) sizeof ( real_T ) ) ) ; ( ( real_T * ) rtDW . bayevhew2y [ 0 ] ) [ 0 ] = rtP . TransportDelay_InitOutput_hb2oc3ff1y ; ( ( real_T * ) rtDW . bayevhew2y [ 0 ] ) [ rtDW . asfvwsoqaf [ 3 ] ] = ssGetT ( rtS ) ; slsaSaveRawMemoryForSimTargetOP ( rtS , "svpwm_inv_ideal_switch_Motor/CurrentsMuxFilter1/Mean/Model/Transport Delay0" , ( void * * ) ( & rtDW . bayevhew2y [ 0 ] ) , ( rtDW . asfvwsoqaf [ 3 ] << 1 ) * sizeof ( real_T ) , NULL , NULL ) ; MdlInitialize ( ) ; } void MdlOutputs ( int_T tid ) { real_T jl44jkf4nn ; real_T oqhxtibsjt ; real_T nkuwrhhxie ; NeParameterBundle expl_temp ; NeslSimulationData * simulationData ; NeuDiagnosticManager * diag ; NeuDiagnosticTree * diagTree ; NeuDiagnosticTree * diagnosticTree ; NeuDiagnosticTree * diagnosticTree_e ; NeuDiagnosticTree * diagnosticTree_i ; NeuDiagnosticTree * diagnosticTree_p ; char * msg ; char * msg_e ; char * msg_i ; char * msg_m ; char * msg_p ; real_T tmp_f [ 123 ] ; real_T tmp_g [ 16 ] ; real_T tmp_i [ 16 ] ; real_T tmp_p [ 16 ] ; real_T tmp [ 9 ] ; real_T dhky1fs0wh ; real_T ktjdaab0c2 ; real_T mojodyhnck ; real_T ndrjxr2plr ; real_T ox5urvtjjn ; real_T time ; real_T time_e ; real_T time_g ; real_T time_i ; real_T time_m ; real_T time_p ; int32_T y ; int_T tmp_c [ 6 ] ; int_T tmp_e [ 5 ] ; int_T tmp_j [ 5 ] ; int_T tmp_m [ 5 ] ; int_T i ; int8_T tmp_b ; int8_T tmp_k ; boolean_T first_output ; boolean_T hadEvents ; rtB . ekk11nkuz3 = 0.0 ; rtB . ekk11nkuz3 += rtP . TransferFcn_C * rtX . mmcyaey4zw ; if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { if ( rtB . ekk11nkuz3 > 0.0 ) { rtDW . l0rt05nc5w = 1 ; } else if ( rtB . ekk11nkuz3 < 0.0 ) { rtDW . l0rt05nc5w = - 1 ; } else { rtDW . l0rt05nc5w = 0 ; } rtB . nvyiuv1zxl = rtDW . l0rt05nc5w ; } rtB . dd0muoybk2 = rtB . ekk11nkuz3 * rtB . ekk11nkuz3 * rtP . Gain2_Gain_hrv0gbf0t1 ; rtB . elycy3b3ad = look1_binlxpw ( rtB . ekk11nkuz3 , rtP . uDLookupTable_bp01Data , rtP . uDLookupTable_tableData , 3U ) + rtB . dd0muoybk2 ; rtB . bpd0kmwwuj = rtB . nvyiuv1zxl * rtB . elycy3b3ad ; rtB . fj3clsrn1n = rtP . Gain_Gain_e32s35ttd5 * rtB . bpd0kmwwuj ; if ( rtDW . p1eaxc4si3 == 0.0 ) { rtDW . p1eaxc4si3 = 1.0 ; rtX . erjd0mhsiq = rtB . fj3clsrn1n ; } rtB . m1glkuwbva [ 0 ] = rtX . erjd0mhsiq ; rtB . m1glkuwbva [ 1 ] = ( rtB . fj3clsrn1n - rtX . erjd0mhsiq ) * 1000.0 ; rtB . m1glkuwbva [ 2 ] = 0.0 ; rtB . m1glkuwbva [ 3 ] = 0.0 ; if ( ssIsSampleHit ( rtS , 2 , 0 ) ) { if ( ssIsSampleHit ( rtS , 4 , 0 ) ) { rtB . mtks2gpnub [ 0 ] = rtDW . fvjpifmnqp [ 0 ] ; rtB . mtks2gpnub [ 1 ] = rtDW . fvjpifmnqp [ 1 ] ; rtB . mtks2gpnub [ 2 ] = rtDW . fvjpifmnqp [ 2 ] ; } if ( rtDW . ohmbboa034 ) { rtDW . ohmbboa034 = false ; rtB . knjptrjfxw = rtP . IntegratorwithWrappedStateDiscreteorContinuous_x0 ; } else { rtB . knjptrjfxw = rtDW . afz1wmfwwl - muDoubleScalarFloor ( 1.0 / ( rtP . PWMGenerator1_Tper - rtP . IntegratorwithWrappedStateDiscreteorContinuous_WrappedStateLowerValue ) * ( rtDW . afz1wmfwwl - rtP . IntegratorwithWrappedStateDiscreteorContinuous_WrappedStateLowerValue ) ) * ( rtP . PWMGenerator1_Tper - rtP . IntegratorwithWrappedStateDiscreteorContinuous_WrappedStateLowerValue ) ; } if ( ( rtDW . afz1wmfwwl < rtP . IntegratorwithWrappedStateDiscreteorContinuous_WrappedStateLowerValue ) || ( rtDW . afz1wmfwwl >= rtP . PWMGenerator1_Tper ) ) { rtDW . afz1wmfwwl = rtB . knjptrjfxw ; } jl44jkf4nn = rtDW . afz1wmfwwl ; ktjdaab0c2 = rtP . PWMGenerator1_Tper / ( rtP . PWMGenerator1_Tper - rtB . hhp3y0oygr [ 0 ] ) * jl44jkf4nn ; mojodyhnck = rtB . hhp3y0oygr [ 0 ] + rtP . PWMGenerator1_Tper ; if ( rtDW . lzwswludg5 ) { rtDW . lzwswludg5 = false ; rtB . iixyxlabma = rtP . PWMGenerator1_Tdelay ; } else { rtB . iixyxlabma = rtDW . l311fk1wdw - muDoubleScalarFloor ( 1.0 / ( 2.0 * rtP . PWMGenerator1_Tper - rtP . IntegratorwithWrappedStateDiscreteorContinuous1_WrappedStateLowerValue ) * ( rtDW . l311fk1wdw - rtP . IntegratorwithWrappedStateDiscreteorContinuous1_WrappedStateLowerValue ) ) * ( 2.0 * rtP . PWMGenerator1_Tper - rtP . IntegratorwithWrappedStateDiscreteorContinuous1_WrappedStateLowerValue ) ; } if ( ( rtDW . l311fk1wdw < rtP . IntegratorwithWrappedStateDiscreteorContinuous1_WrappedStateLowerValue ) || ( rtDW . l311fk1wdw >= 2.0 * rtP . PWMGenerator1_Tper ) ) { rtDW . l311fk1wdw = rtB . iixyxlabma ; } switch ( ( int32_T ) rtP . Carriercounter_CarrCount ) { case 1 : ktjdaab0c2 -= muDoubleScalarFloor ( ktjdaab0c2 / mojodyhnck ) * mojodyhnck ; break ; case 2 : ktjdaab0c2 = rtP . PWMGenerator1_Tper - ( ktjdaab0c2 - muDoubleScalarFloor ( ktjdaab0c2 / mojodyhnck ) * mojodyhnck ) ; break ; default : ktjdaab0c2 = 2.0 * rtP . PWMGenerator1_Tper - rtDW . l311fk1wdw ; if ( rtDW . l311fk1wdw > rtP . PWMGenerator1_Tper ) { ox5urvtjjn = rtP . Constant2_Value ; } else { ox5urvtjjn = rtDW . l311fk1wdw ; } if ( ktjdaab0c2 > rtP . PWMGenerator1_Tper ) { ktjdaab0c2 = rtP . Constant2_Value_mcxfir2knc ; } ktjdaab0c2 += ox5urvtjjn ; break ; } ox5urvtjjn = 1.0 / rtP . PWMGenerator1_Tper * ktjdaab0c2 ; if ( ox5urvtjjn > rtP . Saturation_UpperSat ) { ox5urvtjjn = rtP . Saturation_UpperSat ; } else if ( ox5urvtjjn < rtP . Saturation_LowerSat ) { ox5urvtjjn = rtP . Saturation_LowerSat ; } rtB . ez3qw0cmbe = ( ( rtB . mtks2gpnub [ 1 ] != rtP . Constant_Value_aedbii5zo1 ) && ( rtB . mtks2gpnub [ 1 ] >= rtP . Carriercounter_Range * ox5urvtjjn + ( - rtP . Carriercounter_Range + 1.0 ) ) ) ; } rtB . ipcfdxqbvr [ 0 ] = rtB . ez3qw0cmbe ; rtB . ipcfdxqbvr [ 1 ] = 0.0 ; rtB . ipcfdxqbvr [ 2 ] = 0.0 ; if ( ssIsMajorTimeStep ( rtS ) ) { rtDW . lvtmdk5pzk [ 0 ] = ! ( rtB . ipcfdxqbvr [ 0 ] == rtDW . lvtmdk5pzk [ 1 ] ) ; rtDW . lvtmdk5pzk [ 1 ] = rtB . ipcfdxqbvr [ 0 ] ; } rtB . ipcfdxqbvr [ 0 ] = rtDW . lvtmdk5pzk [ 1 ] ; rtB . ipcfdxqbvr [ 3 ] = rtDW . lvtmdk5pzk [ 0 ] ; if ( ssIsSampleHit ( rtS , 2 , 0 ) ) { if ( rtDW . ee03va2m5d ) { rtDW . ee03va2m5d = false ; rtB . lbfipievkr = rtP . IntegratorwithWrappedStateDiscreteorContinuous_x0_jmi4gwmvri ; } else { rtB . lbfipievkr = rtDW . okewh4umdj - muDoubleScalarFloor ( 1.0 / ( rtP . PWMGenerator2_Tper - rtP . IntegratorwithWrappedStateDiscreteorContinuous_WrappedStateLowerValue_gmxko0ufcx ) * ( rtDW . okewh4umdj - rtP . IntegratorwithWrappedStateDiscreteorContinuous_WrappedStateLowerValue_gmxko0ufcx ) ) * ( rtP . PWMGenerator2_Tper - rtP . IntegratorwithWrappedStateDiscreteorContinuous_WrappedStateLowerValue_gmxko0ufcx ) ; } if ( ( rtDW . okewh4umdj < rtP . IntegratorwithWrappedStateDiscreteorContinuous_WrappedStateLowerValue_gmxko0ufcx ) || ( rtDW . okewh4umdj >= rtP . PWMGenerator2_Tper ) ) { rtDW . okewh4umdj = rtB . lbfipievkr ; } oqhxtibsjt = rtDW . okewh4umdj ; ktjdaab0c2 = rtP . PWMGenerator2_Tper / ( rtP . PWMGenerator2_Tper - rtB . ec040fp0fa [ 0 ] ) * oqhxtibsjt ; mojodyhnck = rtB . ec040fp0fa [ 0 ] + rtP . PWMGenerator2_Tper ; if ( rtDW . lm2wj3hxgc ) { rtDW . lm2wj3hxgc = false ; rtB . amgg2aweyl = rtP . PWMGenerator2_Tdelay ; } else { rtB . amgg2aweyl = rtDW . pzb0hgihqm - muDoubleScalarFloor ( 1.0 / ( 2.0 * rtP . PWMGenerator2_Tper - rtP . IntegratorwithWrappedStateDiscreteorContinuous1_WrappedStateLowerValue_ppty12eo1o ) * ( rtDW . pzb0hgihqm - rtP . IntegratorwithWrappedStateDiscreteorContinuous1_WrappedStateLowerValue_ppty12eo1o ) ) * ( 2.0 * rtP . PWMGenerator2_Tper - rtP . IntegratorwithWrappedStateDiscreteorContinuous1_WrappedStateLowerValue_ppty12eo1o ) ; } if ( ( rtDW . pzb0hgihqm < rtP . IntegratorwithWrappedStateDiscreteorContinuous1_WrappedStateLowerValue_ppty12eo1o ) || ( rtDW . pzb0hgihqm >= 2.0 * rtP . PWMGenerator2_Tper ) ) { rtDW . pzb0hgihqm = rtB . amgg2aweyl ; } switch ( ( int32_T ) rtP . Carriercounter_CarrCount_l1cfgyteuy ) { case 1 : ktjdaab0c2 -= muDoubleScalarFloor ( ktjdaab0c2 / mojodyhnck ) * mojodyhnck ; break ; case 2 : ktjdaab0c2 = rtP . PWMGenerator2_Tper - ( ktjdaab0c2 - muDoubleScalarFloor ( ktjdaab0c2 / mojodyhnck ) * mojodyhnck ) ; break ; default : ktjdaab0c2 = 2.0 * rtP . PWMGenerator2_Tper - rtDW . pzb0hgihqm ; if ( rtDW . pzb0hgihqm > rtP . PWMGenerator2_Tper ) { ox5urvtjjn = rtP . Constant2_Value_pu52vdaelf ; } else { ox5urvtjjn = rtDW . pzb0hgihqm ; } if ( ktjdaab0c2 > rtP . PWMGenerator2_Tper ) { ktjdaab0c2 = rtP . Constant2_Value_fomuzpjuar ; } ktjdaab0c2 += ox5urvtjjn ; break ; } ox5urvtjjn = 1.0 / rtP . PWMGenerator2_Tper * ktjdaab0c2 ; if ( ox5urvtjjn > rtP . Saturation_UpperSat_j5u4qljnv5 ) { ox5urvtjjn = rtP . Saturation_UpperSat_j5u4qljnv5 ; } else if ( ox5urvtjjn < rtP . Saturation_LowerSat_em3rmibbhe ) { ox5urvtjjn = rtP . Saturation_LowerSat_em3rmibbhe ; } rtB . nhbuwczelb = ( ( rtB . mtks2gpnub [ 2 ] != rtP . Constant_Value_otslvflthu ) && ( rtB . mtks2gpnub [ 2 ] >= rtP . Carriercounter_Range_fbb5yen5s5 * ox5urvtjjn + ( - rtP . Carriercounter_Range_fbb5yen5s5 + 1.0 ) ) ) ; } rtB . mpqyczxej3 [ 0 ] = rtB . nhbuwczelb ; rtB . mpqyczxej3 [ 1 ] = 0.0 ; rtB . mpqyczxej3 [ 2 ] = 0.0 ; if ( ssIsMajorTimeStep ( rtS ) ) { rtDW . kr2nbusf3i [ 0 ] = ! ( rtB . mpqyczxej3 [ 0 ] == rtDW . kr2nbusf3i [ 1 ] ) ; rtDW . kr2nbusf3i [ 1 ] = rtB . mpqyczxej3 [ 0 ] ; } rtB . mpqyczxej3 [ 0 ] = rtDW . kr2nbusf3i [ 1 ] ; rtB . mpqyczxej3 [ 3 ] = rtDW . kr2nbusf3i [ 0 ] ; if ( ssIsSampleHit ( rtS , 2 , 0 ) ) { if ( rtDW . pstpl3h2q2 ) { rtDW . pstpl3h2q2 = false ; rtB . f2c4mvklul = rtP . IntegratorwithWrappedStateDiscreteorContinuous_x0_cmhchouter ; } else { rtB . f2c4mvklul = rtDW . liqja2sob3 - muDoubleScalarFloor ( 1.0 / ( rtP . PWMGenerator_Tper - rtP . IntegratorwithWrappedStateDiscreteorContinuous_WrappedStateLowerValue_czzrcv1xs0 ) * ( rtDW . liqja2sob3 - rtP . IntegratorwithWrappedStateDiscreteorContinuous_WrappedStateLowerValue_czzrcv1xs0 ) ) * ( rtP . PWMGenerator_Tper - rtP . IntegratorwithWrappedStateDiscreteorContinuous_WrappedStateLowerValue_czzrcv1xs0 ) ; } if ( ( rtDW . liqja2sob3 < rtP . IntegratorwithWrappedStateDiscreteorContinuous_WrappedStateLowerValue_czzrcv1xs0 ) || ( rtDW . liqja2sob3 >= rtP . PWMGenerator_Tper ) ) { rtDW . liqja2sob3 = rtB . f2c4mvklul ; } nkuwrhhxie = rtDW . liqja2sob3 ; ktjdaab0c2 = rtP . PWMGenerator_Tper / ( rtP . PWMGenerator_Tper - rtB . nysfdpoprp [ 0 ] ) * nkuwrhhxie ; mojodyhnck = rtB . nysfdpoprp [ 0 ] + rtP . PWMGenerator_Tper ; if ( rtDW . nojfuzuk1p ) { rtDW . nojfuzuk1p = false ; rtB . hxwhc32bo0 = rtP . PWMGenerator_Tdelay ; } else { rtB . hxwhc32bo0 = rtDW . inzd25bki4 - muDoubleScalarFloor ( 1.0 / ( 2.0 * rtP . PWMGenerator_Tper - rtP . IntegratorwithWrappedStateDiscreteorContinuous1_WrappedStateLowerValue_cznn0srx2d ) * ( rtDW . inzd25bki4 - rtP . IntegratorwithWrappedStateDiscreteorContinuous1_WrappedStateLowerValue_cznn0srx2d ) ) * ( 2.0 * rtP . PWMGenerator_Tper - rtP . IntegratorwithWrappedStateDiscreteorContinuous1_WrappedStateLowerValue_cznn0srx2d ) ; } if ( ( rtDW . inzd25bki4 < rtP . IntegratorwithWrappedStateDiscreteorContinuous1_WrappedStateLowerValue_cznn0srx2d ) || ( rtDW . inzd25bki4 >= 2.0 * rtP . PWMGenerator_Tper ) ) { rtDW . inzd25bki4 = rtB . hxwhc32bo0 ; } switch ( ( int32_T ) rtP . Carriercounter_CarrCount_pcpzckqge2 ) { case 1 : ktjdaab0c2 -= muDoubleScalarFloor ( ktjdaab0c2 / mojodyhnck ) * mojodyhnck ; break ; case 2 : ktjdaab0c2 = rtP . PWMGenerator_Tper - ( ktjdaab0c2 - muDoubleScalarFloor ( ktjdaab0c2 / mojodyhnck ) * mojodyhnck ) ; break ; default : ktjdaab0c2 = 2.0 * rtP . PWMGenerator_Tper - rtDW . inzd25bki4 ; if ( rtDW . inzd25bki4 > rtP . PWMGenerator_Tper ) { ox5urvtjjn = rtP . Constant2_Value_gkaf0w0kw1 ; } else { ox5urvtjjn = rtDW . inzd25bki4 ; } if ( ktjdaab0c2 > rtP . PWMGenerator_Tper ) { ktjdaab0c2 = rtP . Constant2_Value_pweuhgyjqa ; } ktjdaab0c2 += ox5urvtjjn ; break ; } ox5urvtjjn = 1.0 / rtP . PWMGenerator_Tper * ktjdaab0c2 ; if ( ox5urvtjjn > rtP . Saturation_UpperSat_c1q2ftmtjs ) { ox5urvtjjn = rtP . Saturation_UpperSat_c1q2ftmtjs ; } else if ( ox5urvtjjn < rtP . Saturation_LowerSat_jkunmti0xg ) { ox5urvtjjn = rtP . Saturation_LowerSat_jkunmti0xg ; } rtB . kqiarrulir = ( ( rtB . mtks2gpnub [ 0 ] != rtP . Constant_Value_d51pvnudts ) && ( rtB . mtks2gpnub [ 0 ] >= rtP . Carriercounter_Range_iry5nbrdqx * ox5urvtjjn + ( - rtP . Carriercounter_Range_iry5nbrdqx + 1.0 ) ) ) ; } rtB . embqhexp1p [ 0 ] = rtB . kqiarrulir ; rtB . embqhexp1p [ 1 ] = 0.0 ; rtB . embqhexp1p [ 2 ] = 0.0 ; if ( ssIsMajorTimeStep ( rtS ) ) { rtDW . hz3nw5alev [ 0 ] = ! ( rtB . embqhexp1p [ 0 ] == rtDW . hz3nw5alev [ 1 ] ) ; rtDW . hz3nw5alev [ 1 ] = rtB . embqhexp1p [ 0 ] ; } rtB . embqhexp1p [ 0 ] = rtDW . hz3nw5alev [ 1 ] ; rtB . embqhexp1p [ 3 ] = rtDW . hz3nw5alev [ 0 ] ; if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { if ( rtDW . edfgpbf04f ) { tmp [ 0 ] = rtP . RTP_8519EF23_i_L_Value ; tmp [ 1 ] = rtP . RTP_7A33EE0C_w_Value ; tmp [ 2 ] = rtP . RTP_7551B8C1_torque_Value ; tmp [ 3 ] = rtP . RTP_7551B8C1_angular_position_Value ; tmp [ 4 ] = rtP . RTP_7551B8C1_i_d_Value ; tmp [ 5 ] = rtP . RTP_7551B8C1_i_q_Value ; tmp [ 6 ] = rtP . RTP_12AF5A6E_v_Value ; tmp [ 7 ] = rtP . RTP_6FFE9E78_v_Value ; tmp [ 8 ] = rtP . RTP_7551B8C1_angular_velocity_Value ; diag = rtw_create_diagnostics ( ) ; diagTree = neu_diagnostic_manager_get_initial_tree ( diag ) ; expl_temp . mRealParameters . mN = 9 ; expl_temp . mRealParameters . mX = & tmp [ 0 ] ; expl_temp . mLogicalParameters . mN = 0 ; expl_temp . mLogicalParameters . mX = NULL ; expl_temp . mIntegerParameters . mN = 0 ; expl_temp . mIntegerParameters . mX = NULL ; expl_temp . mIndexParameters . mN = 0 ; expl_temp . mIndexParameters . mX = NULL ; first_output = nesl_rtp_manager_set_rtps ( ( NeslRtpManager * ) rtDW . ofz4qubiel , ssGetT ( rtS ) , expl_temp , diag ) ; if ( ! first_output ) { first_output = error_buffer_is_empty ( ssGetErrorStatus ( rtS ) ) ; if ( first_output ) { msg = rtw_diagnostics_msg ( diagTree ) ; ssSetErrorStatus ( rtS , msg ) ; } } } rtDW . edfgpbf04f = false ; } simulationData = ( NeslSimulationData * ) rtDW . mjaqu4jcnj ; hadEvents = false ; if ( ssIsMajorTimeStep ( rtS ) ) { time = ssGetT ( rtS ) ; simulationData -> mData -> mTime . mN = 1 ; simulationData -> mData -> mTime . mX = & time ; simulationData -> mData -> mContStates . mN = 36 ; simulationData -> mData -> mContStates . mX = & rtX . mmg5sph3io [ 0 ] ; simulationData -> mData -> mDiscStates . mN = 147 ; simulationData -> mData -> mDiscStates . mX = & rtDW . atond0rmxa [ 0 ] ; simulationData -> mData -> mModeVector . mN = 56 ; simulationData -> mData -> mModeVector . mX = & rtDW . c1wtxhepbi [ 0 ] ; first_output = ( ssIsMajorTimeStep ( rtS ) && ssGetRTWSolverInfo ( rtS ) -> foundContZcEvents ) ; simulationData -> mData -> mFoundZcEvents = first_output ; simulationData -> mData -> mHadEvents = false ; simulationData -> mData -> mIsMajorTimeStep = ssIsMajorTimeStep ( rtS ) ; first_output = ( ssGetMdlInfoPtr ( rtS ) -> mdlFlags . solverAssertCheck == 1U ) ; simulationData -> mData -> mIsSolverAssertCheck = first_output ; first_output = ssIsSolverCheckingCIC ( rtS ) ; simulationData -> mData -> mIsSolverCheckingCIC = first_output ; first_output = ssIsSolverComputingJacobian ( rtS ) ; simulationData -> mData -> mIsComputingJacobian = first_output ; simulationData -> mData -> mIsEvaluatingF0 = ( ssGetEvaluatingF0ForJacobian ( rtS ) != 0 ) ; first_output = ssIsSolverRequestingReset ( rtS ) ; simulationData -> mData -> mIsSolverRequestingReset = first_output ; simulationData -> mData -> mIsModeUpdateTimeStep = ssIsModeUpdateTimeStep ( rtS ) ; tmp_e [ 0 ] = 0 ; tmp_p [ 0 ] = rtB . m1glkuwbva [ 0 ] ; tmp_p [ 1 ] = rtB . m1glkuwbva [ 1 ] ; tmp_p [ 2 ] = rtB . m1glkuwbva [ 2 ] ; tmp_p [ 3 ] = rtB . m1glkuwbva [ 3 ] ; tmp_e [ 1 ] = 4 ; tmp_p [ 4 ] = rtB . ipcfdxqbvr [ 0 ] ; tmp_p [ 5 ] = rtB . ipcfdxqbvr [ 1 ] ; tmp_p [ 6 ] = rtB . ipcfdxqbvr [ 2 ] ; tmp_p [ 7 ] = rtB . ipcfdxqbvr [ 3 ] ; tmp_e [ 2 ] = 8 ; tmp_p [ 8 ] = rtB . mpqyczxej3 [ 0 ] ; tmp_p [ 9 ] = rtB . mpqyczxej3 [ 1 ] ; tmp_p [ 10 ] = rtB . mpqyczxej3 [ 2 ] ; tmp_p [ 11 ] = rtB . mpqyczxej3 [ 3 ] ; tmp_e [ 3 ] = 12 ; tmp_p [ 12 ] = rtB . embqhexp1p [ 0 ] ; tmp_p [ 13 ] = rtB . embqhexp1p [ 1 ] ; tmp_p [ 14 ] = rtB . embqhexp1p [ 2 ] ; tmp_p [ 15 ] = rtB . embqhexp1p [ 3 ] ; tmp_e [ 4 ] = 16 ; simulationData -> mData -> mInputValues . mN = 16 ; simulationData -> mData -> mInputValues . mX = & tmp_p [ 0 ] ; simulationData -> mData -> mInputOffsets . mN = 5 ; simulationData -> mData -> mInputOffsets . mX = & tmp_e [ 0 ] ; simulationData -> mData -> mNonSampledZCs . mN = 56 ; simulationData -> mData -> mNonSampledZCs . mX = & rtDW . esszafb052 [ 0 ] ; diag = ( NeuDiagnosticManager * ) rtDW . lt4h1wfkog ; diagnosticTree = neu_diagnostic_manager_get_initial_tree ( diag ) ; y = ne_simulator_method ( ( NeslSimulator * ) rtDW . et4usql3vc , NESL_SIM_ZEROCROSSINGS , simulationData , diag ) ; if ( y != 0 ) { first_output = error_buffer_is_empty ( ssGetErrorStatus ( rtS ) ) ; if ( first_output ) { msg_p = rtw_diagnostics_msg ( diagnosticTree ) ; ssSetErrorStatus ( rtS , msg_p ) ; } } memcpy ( & rtDW . kxqvqgnnqm [ 0 ] , & rtPrevZCX . epxdgu0lml , 56 ) ; for ( i = 0 ; i < 56 ; i ++ ) { y = rt_ZCFcnRefine ( rtDW . mgelhzivq0 [ i ] , & rtDW . kxqvqgnnqm [ i ] , ( rtDW . esszafb052 [ i ] ) ) ; hadEvents = ( ( y != 0 ) || hadEvents ) ; } memcpy ( & rtPrevZCX . epxdgu0lml , & rtDW . kxqvqgnnqm [ 0 ] , 56 ) ; } time_p = ssGetT ( rtS ) ; simulationData -> mData -> mTime . mN = 1 ; simulationData -> mData -> mTime . mX = & time_p ; simulationData -> mData -> mContStates . mN = 36 ; simulationData -> mData -> mContStates . mX = & rtX . mmg5sph3io [ 0 ] ; simulationData -> mData -> mDiscStates . mN = 147 ; simulationData -> mData -> mDiscStates . mX = & rtDW . atond0rmxa [ 0 ] ; simulationData -> mData -> mModeVector . mN = 56 ; simulationData -> mData -> mModeVector . mX = & rtDW . c1wtxhepbi [ 0 ] ; first_output = ( ssIsMajorTimeStep ( rtS ) && ssGetRTWSolverInfo ( rtS ) -> foundContZcEvents ) ; simulationData -> mData -> mFoundZcEvents = first_output ; simulationData -> mData -> mHadEvents = false ; simulationData -> mData -> mIsMajorTimeStep = ssIsMajorTimeStep ( rtS ) ; first_output = ( ssGetMdlInfoPtr ( rtS ) -> mdlFlags . solverAssertCheck == 1U ) ; simulationData -> mData -> mIsSolverAssertCheck = first_output ; first_output = ssIsSolverCheckingCIC ( rtS ) ; simulationData -> mData -> mIsSolverCheckingCIC = first_output ; first_output = ssIsSolverComputingJacobian ( rtS ) ; simulationData -> mData -> mIsComputingJacobian = first_output ; simulationData -> mData -> mIsEvaluatingF0 = ( ssGetEvaluatingF0ForJacobian ( rtS ) != 0 ) ; first_output = ssIsSolverRequestingReset ( rtS ) ; simulationData -> mData -> mIsSolverRequestingReset = first_output ; simulationData -> mData -> mIsModeUpdateTimeStep = ssIsModeUpdateTimeStep ( rtS ) ; tmp_m [ 0 ] = 0 ; tmp_i [ 0 ] = rtB . m1glkuwbva [ 0 ] ; tmp_i [ 1 ] = rtB . m1glkuwbva [ 1 ] ; tmp_i [ 2 ] = rtB . m1glkuwbva [ 2 ] ; tmp_i [ 3 ] = rtB . m1glkuwbva [ 3 ] ; tmp_m [ 1 ] = 4 ; tmp_i [ 4 ] = rtB . ipcfdxqbvr [ 0 ] ; tmp_i [ 5 ] = rtB . ipcfdxqbvr [ 1 ] ; tmp_i [ 6 ] = rtB . ipcfdxqbvr [ 2 ] ; tmp_i [ 7 ] = rtB . ipcfdxqbvr [ 3 ] ; tmp_m [ 2 ] = 8 ; tmp_i [ 8 ] = rtB . mpqyczxej3 [ 0 ] ; tmp_i [ 9 ] = rtB . mpqyczxej3 [ 1 ] ; tmp_i [ 10 ] = rtB . mpqyczxej3 [ 2 ] ; tmp_i [ 11 ] = rtB . mpqyczxej3 [ 3 ] ; tmp_m [ 3 ] = 12 ; tmp_i [ 12 ] = rtB . embqhexp1p [ 0 ] ; tmp_i [ 13 ] = rtB . embqhexp1p [ 1 ] ; tmp_i [ 14 ] = rtB . embqhexp1p [ 2 ] ; tmp_i [ 15 ] = rtB . embqhexp1p [ 3 ] ; tmp_m [ 4 ] = 16 ; simulationData -> mData -> mInputValues . mN = 16 ; simulationData -> mData -> mInputValues . mX = & tmp_i [ 0 ] ; simulationData -> mData -> mInputOffsets . mN = 5 ; simulationData -> mData -> mInputOffsets . mX = & tmp_m [ 0 ] ; simulationData -> mData -> mOutputs . mN = 107 ; simulationData -> mData -> mOutputs . mX = & rtB . omxlfht11w [ 0 ] ; simulationData -> mData -> mTolerances . mN = 0 ; simulationData -> mData -> mTolerances . mX = NULL ; simulationData -> mData -> mCstateHasChanged = false ; simulationData -> mData -> mDstateHasChanged = false ; time_e = ssGetTaskTime ( rtS , 0 ) ; simulationData -> mData -> mTime . mN = 1 ; simulationData -> mData -> mTime . mX = & time_e ; simulationData -> mData -> mSampleHits . mN = 0 ; simulationData -> mData -> mSampleHits . mX = NULL ; simulationData -> mData -> mIsFundamentalSampleHit = false ; simulationData -> mData -> mHadEvents = hadEvents ; diag = ( NeuDiagnosticManager * ) rtDW . lt4h1wfkog ; diagnosticTree_p = neu_diagnostic_manager_get_initial_tree ( diag ) ; y = ne_simulator_method ( ( NeslSimulator * ) rtDW . et4usql3vc , NESL_SIM_OUTPUTS , simulationData , diag ) ; if ( y != 0 ) { first_output = error_buffer_is_empty ( ssGetErrorStatus ( rtS ) ) ; if ( first_output ) { msg_e = rtw_diagnostics_msg ( diagnosticTree_p ) ; ssSetErrorStatus ( rtS , msg_e ) ; } } if ( ssIsMajorTimeStep ( rtS ) && simulationData -> mData -> mCstateHasChanged ) { ssSetBlockStateForSolverChangedAtMajorStep ( rtS ) ; } if ( ssIsMajorTimeStep ( rtS ) && ( simulationData -> mData -> mCstateHasChanged || simulationData -> mData -> mDstateHasChanged ) ) { time_i = ssGetT ( rtS ) ; simulationData -> mData -> mTime . mN = 1 ; simulationData -> mData -> mTime . mX = & time_i ; simulationData -> mData -> mContStates . mN = 36 ; simulationData -> mData -> mContStates . mX = & rtX . mmg5sph3io [ 0 ] ; simulationData -> mData -> mDiscStates . mN = 147 ; simulationData -> mData -> mDiscStates . mX = & rtDW . atond0rmxa [ 0 ] ; simulationData -> mData -> mModeVector . mN = 56 ; simulationData -> mData -> mModeVector . mX = & rtDW . c1wtxhepbi [ 0 ] ; first_output = ( ssIsMajorTimeStep ( rtS ) && ssGetRTWSolverInfo ( rtS ) -> foundContZcEvents ) ; simulationData -> mData -> mFoundZcEvents = first_output ; simulationData -> mData -> mHadEvents = false ; simulationData -> mData -> mIsMajorTimeStep = ssIsMajorTimeStep ( rtS ) ; first_output = ( ssGetMdlInfoPtr ( rtS ) -> mdlFlags . solverAssertCheck == 1U ) ; simulationData -> mData -> mIsSolverAssertCheck = first_output ; first_output = ssIsSolverCheckingCIC ( rtS ) ; simulationData -> mData -> mIsSolverCheckingCIC = first_output ; first_output = ssIsSolverComputingJacobian ( rtS ) ; simulationData -> mData -> mIsComputingJacobian = first_output ; simulationData -> mData -> mIsEvaluatingF0 = ( ssGetEvaluatingF0ForJacobian ( rtS ) != 0 ) ; first_output = ssIsSolverRequestingReset ( rtS ) ; simulationData -> mData -> mIsSolverRequestingReset = first_output ; simulationData -> mData -> mIsModeUpdateTimeStep = ssIsModeUpdateTimeStep ( rtS ) ; tmp_j [ 0 ] = 0 ; tmp_g [ 0 ] = rtB . m1glkuwbva [ 0 ] ; tmp_g [ 1 ] = rtB . m1glkuwbva [ 1 ] ; tmp_g [ 2 ] = rtB . m1glkuwbva [ 2 ] ; tmp_g [ 3 ] = rtB . m1glkuwbva [ 3 ] ; tmp_j [ 1 ] = 4 ; tmp_g [ 4 ] = rtB . ipcfdxqbvr [ 0 ] ; tmp_g [ 5 ] = rtB . ipcfdxqbvr [ 1 ] ; tmp_g [ 6 ] = rtB . ipcfdxqbvr [ 2 ] ; tmp_g [ 7 ] = rtB . ipcfdxqbvr [ 3 ] ; tmp_j [ 2 ] = 8 ; tmp_g [ 8 ] = rtB . mpqyczxej3 [ 0 ] ; tmp_g [ 9 ] = rtB . mpqyczxej3 [ 1 ] ; tmp_g [ 10 ] = rtB . mpqyczxej3 [ 2 ] ; tmp_g [ 11 ] = rtB . mpqyczxej3 [ 3 ] ; tmp_j [ 3 ] = 12 ; tmp_g [ 12 ] = rtB . embqhexp1p [ 0 ] ; tmp_g [ 13 ] = rtB . embqhexp1p [ 1 ] ; tmp_g [ 14 ] = rtB . embqhexp1p [ 2 ] ; tmp_g [ 15 ] = rtB . embqhexp1p [ 3 ] ; tmp_j [ 4 ] = 16 ; simulationData -> mData -> mInputValues . mN = 16 ; simulationData -> mData -> mInputValues . mX = & tmp_g [ 0 ] ; simulationData -> mData -> mInputOffsets . mN = 5 ; simulationData -> mData -> mInputOffsets . mX = & tmp_j [ 0 ] ; simulationData -> mData -> mNonSampledZCs . mN = 56 ; simulationData -> mData -> mNonSampledZCs . mX = & rtDW . esszafb052 [ 0 ] ; diag = ( NeuDiagnosticManager * ) rtDW . lt4h1wfkog ; diagnosticTree_e = neu_diagnostic_manager_get_initial_tree ( diag ) ; y = ne_simulator_method ( ( NeslSimulator * ) rtDW . et4usql3vc , NESL_SIM_ZEROCROSSINGS , simulationData , diag ) ; if ( y != 0 ) { first_output = error_buffer_is_empty ( ssGetErrorStatus ( rtS ) ) ; if ( first_output ) { msg_i = rtw_diagnostics_msg ( diagnosticTree_e ) ; ssSetErrorStatus ( rtS , msg_i ) ; } } for ( i = 0 ; i < 56 ; i ++ ) { rt_ZCFcnRefine ( rtDW . mgelhzivq0 [ i ] , & rtDW . kxqvqgnnqm [ i ] , ( rtDW . esszafb052 [ i ] ) ) ; } memcpy ( & rtPrevZCX . epxdgu0lml , & rtDW . kxqvqgnnqm [ 0 ] , 56 ) ; } simulationData = ( NeslSimulationData * ) rtDW . oxh0jmsh2a ; time_m = ssGetT ( rtS ) ; simulationData -> mData -> mTime . mN = 1 ; simulationData -> mData -> mTime . mX = & time_m ; simulationData -> mData -> mContStates . mN = 0 ; simulationData -> mData -> mContStates . mX = NULL ; simulationData -> mData -> mDiscStates . mN = 0 ; simulationData -> mData -> mDiscStates . mX = & rtDW . nke0o0oxmj ; simulationData -> mData -> mModeVector . mN = 0 ; simulationData -> mData -> mModeVector . mX = & rtDW . iw1wautste ; first_output = ( ssIsMajorTimeStep ( rtS ) && ssGetRTWSolverInfo ( rtS ) -> foundContZcEvents ) ; simulationData -> mData -> mFoundZcEvents = first_output ; simulationData -> mData -> mHadEvents = false ; simulationData -> mData -> mIsMajorTimeStep = ssIsMajorTimeStep ( rtS ) ; first_output = ( ssGetMdlInfoPtr ( rtS ) -> mdlFlags . solverAssertCheck == 1U ) ; simulationData -> mData -> mIsSolverAssertCheck = first_output ; first_output = ssIsSolverCheckingCIC ( rtS ) ; simulationData -> mData -> mIsSolverCheckingCIC = first_output ; simulationData -> mData -> mIsComputingJacobian = false ; simulationData -> mData -> mIsEvaluatingF0 = false ; first_output = ssIsSolverRequestingReset ( rtS ) ; simulationData -> mData -> mIsSolverRequestingReset = first_output ; simulationData -> mData -> mIsModeUpdateTimeStep = ssIsModeUpdateTimeStep ( rtS ) ; tmp_c [ 0 ] = 0 ; tmp_f [ 0 ] = rtB . m1glkuwbva [ 0 ] ; tmp_f [ 1 ] = rtB . m1glkuwbva [ 1 ] ; tmp_f [ 2 ] = rtB . m1glkuwbva [ 2 ] ; tmp_f [ 3 ] = rtB . m1glkuwbva [ 3 ] ; tmp_c [ 1 ] = 4 ; tmp_f [ 4 ] = rtB . ipcfdxqbvr [ 0 ] ; tmp_f [ 5 ] = rtB . ipcfdxqbvr [ 1 ] ; tmp_f [ 6 ] = rtB . ipcfdxqbvr [ 2 ] ; tmp_f [ 7 ] = rtB . ipcfdxqbvr [ 3 ] ; tmp_c [ 2 ] = 8 ; tmp_f [ 8 ] = rtB . mpqyczxej3 [ 0 ] ; tmp_f [ 9 ] = rtB . mpqyczxej3 [ 1 ] ; tmp_f [ 10 ] = rtB . mpqyczxej3 [ 2 ] ; tmp_f [ 11 ] = rtB . mpqyczxej3 [ 3 ] ; tmp_c [ 3 ] = 12 ; tmp_f [ 12 ] = rtB . embqhexp1p [ 0 ] ; tmp_f [ 13 ] = rtB . embqhexp1p [ 1 ] ; tmp_f [ 14 ] = rtB . embqhexp1p [ 2 ] ; tmp_f [ 15 ] = rtB . embqhexp1p [ 3 ] ; tmp_c [ 4 ] = 16 ; memcpy ( & tmp_f [ 16 ] , & rtB . omxlfht11w [ 0 ] , 107U * sizeof ( real_T ) ) ; tmp_c [ 5 ] = 123 ; simulationData -> mData -> mInputValues . mN = 123 ; simulationData -> mData -> mInputValues . mX = & tmp_f [ 0 ] ; simulationData -> mData -> mInputOffsets . mN = 6 ; simulationData -> mData -> mInputOffsets . mX = & tmp_c [ 0 ] ; simulationData -> mData -> mOutputs . mN = 14 ; simulationData -> mData -> mOutputs . mX = & rtB . nlfkewwkrq [ 0 ] ; simulationData -> mData -> mTolerances . mN = 0 ; simulationData -> mData -> mTolerances . mX = NULL ; simulationData -> mData -> mCstateHasChanged = false ; simulationData -> mData -> mDstateHasChanged = false ; time_g = ssGetTaskTime ( rtS , 0 ) ; simulationData -> mData -> mTime . mN = 1 ; simulationData -> mData -> mTime . mX = & time_g ; simulationData -> mData -> mSampleHits . mN = 0 ; simulationData -> mData -> mSampleHits . mX = NULL ; simulationData -> mData -> mIsFundamentalSampleHit = false ; simulationData -> mData -> mHadEvents = false ; diag = ( NeuDiagnosticManager * ) rtDW . h3xczpc1e2 ; diagnosticTree_i = neu_diagnostic_manager_get_initial_tree ( diag ) ; y = ne_simulator_method ( ( NeslSimulator * ) rtDW . e45uxvk1lw , NESL_SIM_OUTPUTS , simulationData , diag ) ; if ( y != 0 ) { first_output = error_buffer_is_empty ( ssGetErrorStatus ( rtS ) ) ; if ( first_output ) { msg_m = rtw_diagnostics_msg ( diagnosticTree_i ) ; ssSetErrorStatus ( rtS , msg_m ) ; } } if ( ssIsMajorTimeStep ( rtS ) && simulationData -> mData -> mCstateHasChanged ) { ssSetBlockStateForSolverChangedAtMajorStep ( rtS ) ; } ktjdaab0c2 = rtB . nlfkewwkrq [ 3 ] + rtP . Bias2_Bias ; rtB . bpu0xfzkw1 = muDoubleScalarMod ( ktjdaab0c2 , rtP . Constant_Value_mumexc0o4r ) ; rtB . fn0xsynz42 = muDoubleScalarMod ( ktjdaab0c2 + rtP . Bias_Bias , rtP . Constant5_Value ) ; rtB . f5zsaldpbf = muDoubleScalarMod ( ktjdaab0c2 + rtP . Bias1_Bias , rtP . Constant10_Value ) ; if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { if ( ssIsModeUpdateTimeStep ( rtS ) ) { rtDW . ewzwsaruv2 = ( rtB . bpu0xfzkw1 <= rtP . Constant1_Value_bvfdufyota ) ; rtDW . gubchl0bkg = ( rtB . fn0xsynz42 <= rtP . Constant7_Value ) ; rtDW . ismih1kb3k = ( rtB . f5zsaldpbf <= rtP . Constant11_Value ) ; } rtB . lh4lpppnmp = rtDW . ewzwsaruv2 ; rtB . gubi0njiax = rtDW . gubchl0bkg ; rtB . avn5nipjpe = rtDW . ismih1kb3k ; } if ( ssIsSampleHit ( rtS , 3 , 0 ) ) { rtDW . mimt35h5ox = kzdynaaz2j ; y = ( ( rtB . gubi0njiax << 1 ) + rtB . lh4lpppnmp ) + ( rtB . avn5nipjpe << 2 ) ; if ( y == 3 ) { ox5urvtjjn = 0.52359877559829882 ; dhky1fs0wh = 0.52359877559829882 ; } else if ( y == 1 ) { ox5urvtjjn = 1.5707963267948966 ; dhky1fs0wh = 1.5707963267948966 ; } else if ( y == 5 ) { ox5urvtjjn = 2.6179938779914944 ; dhky1fs0wh = 2.6179938779914944 ; } else if ( y == 4 ) { ox5urvtjjn = 3.6651914291880918 ; dhky1fs0wh = 3.6651914291880918 ; } else if ( y == 6 ) { ox5urvtjjn = 4.71238898038469 ; dhky1fs0wh = 4.71238898038469 ; } else if ( y == 2 ) { ox5urvtjjn = 5.7595865315812871 ; dhky1fs0wh = 5.7595865315812871 ; } else { ox5urvtjjn = 0.0 ; dhky1fs0wh = 0.0 ; } ktjdaab0c2 = dhky1fs0wh - 0.52359877559829882 ; if ( ! rtDW . cgbt3rljof ) { rtDW . fwnd4bigmd = ox5urvtjjn - 0.52359877559829882 ; rtDW . cgbt3rljof = true ; } if ( ox5urvtjjn - 0.52359877559829882 != rtDW . fwnd4bigmd ) { mojodyhnck = ( ox5urvtjjn - 0.52359877559829882 ) - rtDW . fwnd4bigmd ; if ( mojodyhnck < 0.0 ) { mojodyhnck += 6.2831853071795862 ; } mojodyhnck = mojodyhnck / 2.5E-5 / ( rtDW . e0jxwlk51j + 1.0 ) ; if ( muDoubleScalarAbs ( mojodyhnck - rtDW . an2k1o2b34 ) < muDoubleScalarMax ( muDoubleScalarAbs ( rtDW . an2k1o2b34 * 0.5 ) , 500.0 ) ) { rtDW . an2k1o2b34 = mojodyhnck ; } rtDW . e0jxwlk51j = 0.0 ; } else { rtDW . e0jxwlk51j ++ ; } rtDW . czk0zyr4wh += ( rtDW . an2k1o2b34 - rtDW . czk0zyr4wh ) * 0.0125 ; rtDW . fwnd4bigmd = ox5urvtjjn - 0.52359877559829882 ; if ( ! ( rtDW . czk0zyr4wh < 500.0 ) ) { ktjdaab0c2 = rtDW . czk0zyr4wh * 2.5E-5 * ( rtDW . e0jxwlk51j + 1.0 ) + ( ox5urvtjjn - 0.52359877559829882 ) ; } while ( ktjdaab0c2 > 6.2831853071795862 ) { ktjdaab0c2 -= 6.2831853071795862 ; } rtB . opjvd5ozy1 = rtDW . czk0zyr4wh ; rtB . adyv0gvv5b = ktjdaab0c2 ; } rtB . ja5uzywmgg = 0.0 ; rtB . ja5uzywmgg += rtP . TransferFcn1_C * rtX . lqcuiwaata ; rtB . h4qjgjncyb = 0.0 ; rtB . h4qjgjncyb += rtP . TransferFcn2_C * rtX . fqujvrhmxc ; rtB . pa2zy4mpwv = 0.0 ; rtB . pa2zy4mpwv += rtP . TransferFcn3_C * rtX . lvqvgep4z3 ; rtB . plf0bzyoir = rtX . c1dvebixah ; ox5urvtjjn = rt_TDelayInterpolate ( ssGetT ( rtS ) - rtP . TransportDelay_Delay , rtDW . apb44q1alb , ( real_T * ) rtDW . lhset4od0v [ 0 ] , rtDW . pgnkj0dpye [ 3 ] , & rtDW . pgnkj0dpye [ 2 ] , rtDW . pgnkj0dpye [ 0 ] , rtDW . pgnkj0dpye [ 1 ] , rtP . TransportDelay_InitOutput , false , ssIsMinorTimeStep ( rtS ) && ( ( ( real_T * ) rtDW . lhset4od0v [ 0 ] ) [ rtDW . pgnkj0dpye [ 1 ] + rtDW . pgnkj0dpye [ 3 ] ] == ssGetT ( rtS ) ) ) ; if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { rtB . at5nwuloys = rtP . K1_Value ; rtB . bdt1inr5hx = rtDW . fvqqusvlbd ; } if ( ssGetT ( rtS ) >= rtB . at5nwuloys ) { rtB . jkvtbzrsci = ( rtB . plf0bzyoir - ox5urvtjjn ) * rtP . Gain_Gain_pfjbetl5p1 ; } else { rtB . jkvtbzrsci = rtB . bdt1inr5hx ; } rtB . g35x4wcrqq = rtX . bufufyp5jw ; dhky1fs0wh = rt_TDelayInterpolate ( ssGetT ( rtS ) - rtP . TransportDelay_Delay_nvpgxsgedh , rtDW . lj0scfk3vh , ( real_T * ) rtDW . htnluil54k [ 0 ] , rtDW . lf1hqp3kgd [ 3 ] , & rtDW . lf1hqp3kgd [ 2 ] , rtDW . lf1hqp3kgd [ 0 ] , rtDW . lf1hqp3kgd [ 1 ] , rtP . TransportDelay_InitOutput_mvnxyosv3m , false , ssIsMinorTimeStep ( rtS ) && ( ( ( real_T * ) rtDW . htnluil54k [ 0 ] ) [ rtDW . lf1hqp3kgd [ 1 ] + rtDW . lf1hqp3kgd [ 3 ] ] == ssGetT ( rtS ) ) ) ; if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { rtB . fve1hufcvc = rtP . K1_Value_nit54kbtj3 ; rtB . nxeoo33jua = rtDW . ch151dnkqe ; } if ( ssGetT ( rtS ) >= rtB . fve1hufcvc ) { rtB . odobza0ien = ( rtB . g35x4wcrqq - dhky1fs0wh ) * rtP . Gain_Gain_ll5pcfvhs0 ; } else { rtB . odobza0ien = rtB . nxeoo33jua ; } rtB . fwyauue1r3 = rtX . nrr4jufios ; ndrjxr2plr = rt_TDelayInterpolate ( ssGetT ( rtS ) - rtP . TransportDelay_Delay_gvvsfgtvem , rtDW . b2c3cqi0k1 , ( real_T * ) rtDW . bayevhew2y [ 0 ] , rtDW . asfvwsoqaf [ 3 ] , & rtDW . asfvwsoqaf [ 2 ] , rtDW . asfvwsoqaf [ 0 ] , rtDW . asfvwsoqaf [ 1 ] , rtP . TransportDelay_InitOutput_hb2oc3ff1y , false , ssIsMinorTimeStep ( rtS ) && ( ( ( real_T * ) rtDW . bayevhew2y [ 0 ] ) [ rtDW . asfvwsoqaf [ 1 ] + rtDW . asfvwsoqaf [ 3 ] ] == ssGetT ( rtS ) ) ) ; if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { rtB . hbx1vtkzuw = rtP . K1_Value_bgr15xvg3f ; rtB . ndd0zuh2um = rtDW . imtaqygzf4 ; } if ( ssGetT ( rtS ) >= rtB . hbx1vtkzuw ) { rtB . l1db0zw3xd = ( rtB . fwyauue1r3 - ndrjxr2plr ) * rtP . Gain_Gain ; } else { rtB . l1db0zw3xd = rtB . ndd0zuh2um ; } rtB . hmxjsv2cvd = 0.0 ; rtB . hmxjsv2cvd += rtP . TransferFcn_C_bb501r2khh * rtX . adzjcfmnhs ; rtB . izoggj010e = rtB . jubdn5alh2 - rtB . hmxjsv2cvd ; if ( ssIsSampleHit ( rtS , 2 , 0 ) ) { } ktjdaab0c2 = ( rtB . ja5uzywmgg - ( ( rtB . ja5uzywmgg + rtB . h4qjgjncyb ) + rtB . pa2zy4mpwv ) * rtP . one_by_3_Gain_ftvqyvuzmt ) * rtP . Kalphabeta0_Gain_ilfd34dpsq [ 0 ] ; mojodyhnck = ( rtB . h4qjgjncyb - rtB . pa2zy4mpwv ) * rtP . one_by_sqrt3_Gain_pgvhkr2jgu * rtP . Kalphabeta0_Gain_ilfd34dpsq [ 1 ] ; dhky1fs0wh = rtP . Gain1_Gain_nxhl14je3b * rtB . nlfkewwkrq [ 3 ] ; ox5urvtjjn = muDoubleScalarSin ( dhky1fs0wh ) ; dhky1fs0wh = muDoubleScalarCos ( dhky1fs0wh ) ; if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { rtB . grzukuw54p = rtP . Offset_Value ; } rtB . m2fmd2xvn0 = mojodyhnck * dhky1fs0wh ; rtB . ap0cz5mhpy = ktjdaab0c2 * ox5urvtjjn ; rtB . fz44qd5gkn = rtB . m2fmd2xvn0 - rtB . ap0cz5mhpy ; rtB . ct3lcbtol5 = ktjdaab0c2 * dhky1fs0wh ; rtB . ilrzcuq4cf = mojodyhnck * ox5urvtjjn ; rtB . ka5csqzys5 = rtB . ct3lcbtol5 + rtB . ilrzcuq4cf ; if ( rtB . grzukuw54p > rtP . Switch_Threshold ) { rtB . ml31xvpomk [ 0 ] = - rtB . fz44qd5gkn ; rtB . ml31xvpomk [ 1 ] = rtB . ka5csqzys5 ; } else { rtB . ml31xvpomk [ 0 ] = rtB . ka5csqzys5 ; rtB . ml31xvpomk [ 1 ] = rtB . fz44qd5gkn ; } rtB . pjlyxcfs2b = rtB . ml31xvpomk [ 0 ] ; rtB . o3tqnmn43y = rtB . ml31xvpomk [ 1 ] ; if ( ssIsSampleHit ( rtS , 5 , 0 ) ) { ox5urvtjjn = rtP . PIDController2_P * rtB . izoggj010e + rtDW . myxkp4g3jb ; if ( ox5urvtjjn > rtP . PIDController2_UpperSaturationLimit ) { ox5urvtjjn -= rtP . PIDController2_UpperSaturationLimit ; } else if ( ox5urvtjjn >= rtP . PIDController2_LowerSaturationLimit ) { ox5urvtjjn = 0.0 ; } else { ox5urvtjjn -= rtP . PIDController2_LowerSaturationLimit ; } dhky1fs0wh = rtP . PIDController2_I * rtB . izoggj010e ; if ( ox5urvtjjn > rtP . Clamping_zero_Value ) { tmp_k = rtP . Constant_Value_jztjkp0m2j ; } else { tmp_k = rtP . Constant2_Value_d2bnea0b2y ; } if ( dhky1fs0wh > rtP . Clamping_zero_Value ) { tmp_b = rtP . Constant3_Value_ijyrlqhtqs ; } else { tmp_b = rtP . Constant4_Value ; } if ( ( rtP . Clamping_zero_Value != ox5urvtjjn ) && ( tmp_k == tmp_b ) ) { rtB . desxhsenu1 = rtP . Constant1_Value_jszzsjitnn ; } else { rtB . desxhsenu1 = dhky1fs0wh ; } } if ( ssIsSampleHit ( rtS , 4 , 0 ) && ssIsSampleHit ( rtS , 4 , 0 ) ) { ktjdaab0c2 = ( rtB . ja5uzywmgg - ( ( rtB . ja5uzywmgg + rtB . h4qjgjncyb ) + rtB . pa2zy4mpwv ) * rtP . one_by_3_Gain ) * rtP . Kalphabeta0_Gain [ 0 ] ; mojodyhnck = ( rtB . h4qjgjncyb - rtB . pa2zy4mpwv ) * rtP . one_by_sqrt3_Gain * rtP . Kalphabeta0_Gain [ 1 ] ; ox5urvtjjn = rtP . Gain1_Gain * rtB . nlfkewwkrq [ 4 ] ; rtB . k0t1wtmr5q = rtB . nlfkewwkrq [ 3 ] + ox5urvtjjn ; rtB . pvfoltfune = muDoubleScalarSin ( rtB . k0t1wtmr5q ) ; rtB . eqqft4qpkb = muDoubleScalarCos ( rtB . k0t1wtmr5q ) ; if ( rtP . Offset_Value_l5jnuwrncz > rtP . Switch_Threshold_ol0hmyrsdr ) { rtB . bo5cwqikij = - ( mojodyhnck * rtB . eqqft4qpkb - ktjdaab0c2 * rtB . pvfoltfune ) ; rtB . n0uh2lwref = ktjdaab0c2 * rtB . eqqft4qpkb + mojodyhnck * rtB . pvfoltfune ; } else { rtB . bo5cwqikij = ktjdaab0c2 * rtB . eqqft4qpkb + mojodyhnck * rtB . pvfoltfune ; rtB . n0uh2lwref = mojodyhnck * rtB . eqqft4qpkb - ktjdaab0c2 * rtB . pvfoltfune ; } rtB . mzjl13czwr = rtB . hpidpxqnfq - rtB . bo5cwqikij ; rtB . i5rkytt3xy = rtP . PIDController3_P * rtB . mzjl13czwr + rtDW . gcyhq2afeb ; ox5urvtjjn = rtB . n0uh2lwref * rtB . nlfkewwkrq [ 4 ] ; ox5urvtjjn = rtB . i5rkytt3xy - rtP . Gain4_Gain * ox5urvtjjn ; rtB . a4lv0iyskh = rtB . jsnwfcg0hl - rtB . n0uh2lwref ; dhky1fs0wh = rtP . Gain2_Gain * rtB . nlfkewwkrq [ 4 ] ; rtB . cxjwsljzkc = ( rtP . PIDController4_P * rtB . a4lv0iyskh + rtDW . p4cmclm0n5 ) + rtP . Gain3_Gain * dhky1fs0wh ; if ( rtP . Offset_Value_liidbyyeg5 > rtP . Switch_Threshold_ot3e5nk2jb ) { dhky1fs0wh = rtB . cxjwsljzkc * rtB . eqqft4qpkb + ox5urvtjjn * rtB . pvfoltfune ; ox5urvtjjn = - ( ox5urvtjjn * rtB . eqqft4qpkb - rtB . cxjwsljzkc * rtB . pvfoltfune ) ; } else { dhky1fs0wh = ox5urvtjjn * rtB . eqqft4qpkb - rtB . cxjwsljzkc * rtB . pvfoltfune ; ox5urvtjjn = rtB . cxjwsljzkc * rtB . eqqft4qpkb + ox5urvtjjn * rtB . pvfoltfune ; } rtB . or0ttvwbd0 = muDoubleScalarHypot ( dhky1fs0wh , ox5urvtjjn ) ; rtB . p14rrqllfn = muDoubleScalarAtan2 ( ox5urvtjjn , dhky1fs0wh ) ; ox5urvtjjn = rtP . Gain_Gain_n41ssx3siy * rtB . nlfkewwkrq [ 12 ] ; rtB . mhnxkimy3i = muDoubleScalarSqrt ( ox5urvtjjn * ox5urvtjjn - rtB . i5rkytt3xy * rtB . i5rkytt3xy ) ; rtB . n4ts4dtcsq = rtP . PIDController3_I * rtB . mzjl13czwr ; rtB . akq1ntnmq3 = rtP . PIDController4_I * rtB . a4lv0iyskh ; rtDW . b4jd5d00a5 = kzdynaaz2j ; if ( rtB . p14rrqllfn < 0.0 ) { ox5urvtjjn = rtB . p14rrqllfn + 6.2831853071795862 ; } else { ox5urvtjjn = rtB . p14rrqllfn ; } if ( ( ox5urvtjjn >= 0.0 ) && ( ox5urvtjjn < 1.0471975511965976 ) ) { y = 1 ; } else if ( ( ox5urvtjjn >= 1.0471975511965976 ) && ( ox5urvtjjn < 2.0943951023931953 ) ) { y = 2 ; } else if ( ( ox5urvtjjn >= 2.0943951023931953 ) && ( ox5urvtjjn < 3.1415926535897931 ) ) { y = 3 ; } else if ( ( ox5urvtjjn >= 3.1415926535897931 ) && ( ox5urvtjjn < 4.1887902047863905 ) ) { y = 4 ; } else if ( ( ox5urvtjjn >= 4.1887902047863905 ) && ( ox5urvtjjn < 5.2359877559829888 ) ) { y = 5 ; } else { y = 6 ; } dhky1fs0wh = ox5urvtjjn - ( ( real_T ) y - 1.0 ) * 3.1415926535897931 / 3.0 ; ox5urvtjjn = 1.7320508075688772 * rtB . or0ttvwbd0 / rtB . nlfkewwkrq [ 12 ] * muDoubleScalarSin ( 1.0471975511965976 - dhky1fs0wh ) ; ktjdaab0c2 = 1.7320508075688772 * rtB . or0ttvwbd0 / rtB . nlfkewwkrq [ 12 ] * muDoubleScalarSin ( dhky1fs0wh ) ; mojodyhnck = ( 1.0 - ox5urvtjjn ) - ktjdaab0c2 ; switch ( y ) { case 1 : dhky1fs0wh = ( ox5urvtjjn + ktjdaab0c2 ) + mojodyhnck / 2.0 ; ndrjxr2plr = mojodyhnck / 2.0 + ktjdaab0c2 ; ox5urvtjjn = mojodyhnck / 2.0 ; break ; case 2 : dhky1fs0wh = mojodyhnck / 2.0 + ox5urvtjjn ; ndrjxr2plr = ( ox5urvtjjn + ktjdaab0c2 ) + mojodyhnck / 2.0 ; ox5urvtjjn = mojodyhnck / 2.0 ; break ; case 3 : dhky1fs0wh = mojodyhnck / 2.0 ; ndrjxr2plr = ( ox5urvtjjn + ktjdaab0c2 ) + mojodyhnck / 2.0 ; ox5urvtjjn = mojodyhnck / 2.0 + ktjdaab0c2 ; break ; case 4 : dhky1fs0wh = mojodyhnck / 2.0 ; ndrjxr2plr = mojodyhnck / 2.0 + ox5urvtjjn ; ox5urvtjjn = ( ox5urvtjjn + ktjdaab0c2 ) + mojodyhnck / 2.0 ; break ; case 5 : dhky1fs0wh = mojodyhnck / 2.0 + ktjdaab0c2 ; ndrjxr2plr = mojodyhnck / 2.0 ; ox5urvtjjn = ( ox5urvtjjn + ktjdaab0c2 ) + mojodyhnck / 2.0 ; break ; default : dhky1fs0wh = ( ox5urvtjjn + ktjdaab0c2 ) + mojodyhnck / 2.0 ; ndrjxr2plr = mojodyhnck / 2.0 ; ox5urvtjjn += mojodyhnck / 2.0 ; break ; } if ( dhky1fs0wh > 0.95 ) { dhky1fs0wh = 0.95 ; } else if ( dhky1fs0wh < 0.05 ) { dhky1fs0wh = 0.05 ; } if ( ndrjxr2plr > 0.95 ) { ndrjxr2plr = 0.95 ; } else if ( ndrjxr2plr < 0.05 ) { ndrjxr2plr = 0.05 ; } if ( ox5urvtjjn > 0.95 ) { ox5urvtjjn = 0.95 ; } else if ( ox5urvtjjn < 0.05 ) { ox5urvtjjn = 0.05 ; } if ( rtDW . jmydjkcywd > 10.0 ) { rtB . hcjia010du = dhky1fs0wh ; rtB . nwivc1gook = ndrjxr2plr ; rtB . fkzcqvy1u1 = ox5urvtjjn ; } else { rtB . hcjia010du = 0.5 ; rtB . nwivc1gook = 0.5 ; rtB . fkzcqvy1u1 = 0.5 ; rtDW . jmydjkcywd ++ ; } } if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { rtDW . gnwzr0jyb5 = ( ssGetTaskTime ( rtS , 1 ) >= rtP . Ramp_start ) ; rtDW . dj01vpxxe4 = ( ssGetTaskTime ( rtS , 1 ) >= rtP . Ramp1_start ) ; } UNUSED_PARAMETER ( tid ) ; } void MdlOutputsTID6 ( int_T tid ) { rtB . jsnwfcg0hl = rtP . Constant_Value_n3iuon0ekq ; rtB . jubdn5alh2 = rtP . Constant2_Value_adqopcdcxe ; rtB . hpidpxqnfq = rtP . Constant3_Value ; UNUSED_PARAMETER ( tid ) ; } void MdlUpdate ( int_T tid ) { NeslSimulationData * simulationData ; NeuDiagnosticManager * diagnosticManager ; NeuDiagnosticTree * diagnosticTree ; char * msg ; real_T tmp [ 16 ] ; real_T time ; int_T tmp_p [ 5 ] ; int_T i ; boolean_T bufferFull ; if ( ssIsSampleHit ( rtS , 4 , 0 ) ) { rtDW . fvjpifmnqp [ 0 ] = rtB . hcjia010du ; rtDW . fvjpifmnqp [ 1 ] = rtB . nwivc1gook ; rtDW . fvjpifmnqp [ 2 ] = rtB . fkzcqvy1u1 ; } if ( ssIsSampleHit ( rtS , 2 , 0 ) ) { rtDW . afz1wmfwwl += rtP . Integrator_gainval_mrdvyychkv * rtP . Constant3_Value_j4b4zpsigk ; rtDW . l311fk1wdw += rtP . Integrator_gainval_c0fk5uxyeb * rtP . Constant3_Value_j4b4zpsigk ; rtDW . okewh4umdj += rtP . Integrator_gainval_b2tc3y3sp3 * rtP . Constant3_Value_ltnm24yy5d ; rtDW . pzb0hgihqm += rtP . Integrator_gainval_ginifr2xlq * rtP . Constant3_Value_ltnm24yy5d ; rtDW . liqja2sob3 += rtP . Integrator_gainval_clmxe4wonv * rtP . Constant3_Value_lk0wk5gj3a ; rtDW . inzd25bki4 += rtP . Integrator_gainval_lsanfb5e3f * rtP . Constant3_Value_lk0wk5gj3a ; } simulationData = ( NeslSimulationData * ) rtDW . mjaqu4jcnj ; time = ssGetT ( rtS ) ; simulationData -> mData -> mTime . mN = 1 ; simulationData -> mData -> mTime . mX = & time ; simulationData -> mData -> mContStates . mN = 36 ; simulationData -> mData -> mContStates . mX = & rtX . mmg5sph3io [ 0 ] ; simulationData -> mData -> mDiscStates . mN = 147 ; simulationData -> mData -> mDiscStates . mX = & rtDW . atond0rmxa [ 0 ] ; simulationData -> mData -> mModeVector . mN = 56 ; simulationData -> mData -> mModeVector . mX = & rtDW . c1wtxhepbi [ 0 ] ; bufferFull = ( ssIsMajorTimeStep ( rtS ) && ssGetRTWSolverInfo ( rtS ) -> foundContZcEvents ) ; simulationData -> mData -> mFoundZcEvents = bufferFull ; simulationData -> mData -> mHadEvents = false ; simulationData -> mData -> mIsMajorTimeStep = ssIsMajorTimeStep ( rtS ) ; bufferFull = ( ssGetMdlInfoPtr ( rtS ) -> mdlFlags . solverAssertCheck == 1U ) ; simulationData -> mData -> mIsSolverAssertCheck = bufferFull ; bufferFull = ssIsSolverCheckingCIC ( rtS ) ; simulationData -> mData -> mIsSolverCheckingCIC = bufferFull ; bufferFull = ssIsSolverComputingJacobian ( rtS ) ; simulationData -> mData -> mIsComputingJacobian = bufferFull ; simulationData -> mData -> mIsEvaluatingF0 = ( ssGetEvaluatingF0ForJacobian ( rtS ) != 0 ) ; bufferFull = ssIsSolverRequestingReset ( rtS ) ; simulationData -> mData -> mIsSolverRequestingReset = bufferFull ; simulationData -> mData -> mIsModeUpdateTimeStep = ssIsModeUpdateTimeStep ( rtS ) ; tmp_p [ 0 ] = 0 ; tmp [ 0 ] = rtB . m1glkuwbva [ 0 ] ; tmp [ 1 ] = rtB . m1glkuwbva [ 1 ] ; tmp [ 2 ] = rtB . m1glkuwbva [ 2 ] ; tmp [ 3 ] = rtB . m1glkuwbva [ 3 ] ; tmp_p [ 1 ] = 4 ; tmp [ 4 ] = rtB . ipcfdxqbvr [ 0 ] ; tmp [ 5 ] = rtB . ipcfdxqbvr [ 1 ] ; tmp [ 6 ] = rtB . ipcfdxqbvr [ 2 ] ; tmp [ 7 ] = rtB . ipcfdxqbvr [ 3 ] ; tmp_p [ 2 ] = 8 ; tmp [ 8 ] = rtB . mpqyczxej3 [ 0 ] ; tmp [ 9 ] = rtB . mpqyczxej3 [ 1 ] ; tmp [ 10 ] = rtB . mpqyczxej3 [ 2 ] ; tmp [ 11 ] = rtB . mpqyczxej3 [ 3 ] ; tmp_p [ 3 ] = 12 ; tmp [ 12 ] = rtB . embqhexp1p [ 0 ] ; tmp [ 13 ] = rtB . embqhexp1p [ 1 ] ; tmp [ 14 ] = rtB . embqhexp1p [ 2 ] ; tmp [ 15 ] = rtB . embqhexp1p [ 3 ] ; tmp_p [ 4 ] = 16 ; simulationData -> mData -> mInputValues . mN = 16 ; simulationData -> mData -> mInputValues . mX = & tmp [ 0 ] ; simulationData -> mData -> mInputOffsets . mN = 5 ; simulationData -> mData -> mInputOffsets . mX = & tmp_p [ 0 ] ; diagnosticManager = ( NeuDiagnosticManager * ) rtDW . lt4h1wfkog ; diagnosticTree = neu_diagnostic_manager_get_initial_tree ( diagnosticManager ) ; i = ne_simulator_method ( ( NeslSimulator * ) rtDW . et4usql3vc , NESL_SIM_UPDATE , simulationData , diagnosticManager ) ; if ( i != 0 ) { bufferFull = error_buffer_is_empty ( ssGetErrorStatus ( rtS ) ) ; if ( bufferFull ) { msg = rtw_diagnostics_msg ( diagnosticTree ) ; ssSetErrorStatus ( rtS , msg ) ; } } bufferFull = false ; if ( rtDW . pgnkj0dpye [ 1 ] < rtDW . pgnkj0dpye [ 3 ] - 1 ) { rtDW . pgnkj0dpye [ 1 ] ++ ; } else { rtDW . pgnkj0dpye [ 1 ] = 0 ; } if ( rtDW . pgnkj0dpye [ 0 ] == rtDW . pgnkj0dpye [ 1 ] ) { bufferFull = true ; rt_TDelayUpdateTailOrGrowBuf ( & rtDW . pgnkj0dpye [ 3 ] , & rtDW . pgnkj0dpye [ 0 ] , & rtDW . pgnkj0dpye [ 1 ] , & rtDW . pgnkj0dpye [ 2 ] , ssGetT ( rtS ) - rtP . TransportDelay_Delay , ( real_T * * ) & rtDW . lhset4od0v [ 0 ] , false , false , & rtDW . pgnkj0dpye [ 4 ] ) ; } ( ( real_T * ) rtDW . lhset4od0v [ 0 ] ) [ rtDW . pgnkj0dpye [ 1 ] ] = rtB . plf0bzyoir ; ( ( real_T * ) rtDW . lhset4od0v [ 0 ] ) [ rtDW . pgnkj0dpye [ 1 ] + rtDW . pgnkj0dpye [ 3 ] ] = ssGetT ( rtS ) ; if ( bufferFull ) { slsaSaveRawMemoryForSimTargetOP ( rtS , "svpwm_inv_ideal_switch_Motor/CurrentsMuxFilter1/Mean2/Model/Transport Delay0" , ( void * * ) ( & rtDW . lhset4od0v [ 0 ] ) , ( rtDW . pgnkj0dpye [ 3 ] << 1 ) * sizeof ( real_T ) , NULL , NULL ) ; } if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { rtDW . fvqqusvlbd = rtB . jkvtbzrsci ; } bufferFull = false ; if ( rtDW . lf1hqp3kgd [ 1 ] < rtDW . lf1hqp3kgd [ 3 ] - 1 ) { rtDW . lf1hqp3kgd [ 1 ] ++ ; } else { rtDW . lf1hqp3kgd [ 1 ] = 0 ; } if ( rtDW . lf1hqp3kgd [ 0 ] == rtDW . lf1hqp3kgd [ 1 ] ) { bufferFull = true ; rt_TDelayUpdateTailOrGrowBuf ( & rtDW . lf1hqp3kgd [ 3 ] , & rtDW . lf1hqp3kgd [ 0 ] , & rtDW . lf1hqp3kgd [ 1 ] , & rtDW . lf1hqp3kgd [ 2 ] , ssGetT ( rtS ) - rtP . TransportDelay_Delay_nvpgxsgedh , ( real_T * * ) & rtDW . htnluil54k [ 0 ] , false , false , & rtDW . lf1hqp3kgd [ 4 ] ) ; } ( ( real_T * ) rtDW . htnluil54k [ 0 ] ) [ rtDW . lf1hqp3kgd [ 1 ] ] = rtB . g35x4wcrqq ; ( ( real_T * ) rtDW . htnluil54k [ 0 ] ) [ rtDW . lf1hqp3kgd [ 1 ] + rtDW . lf1hqp3kgd [ 3 ] ] = ssGetT ( rtS ) ; if ( bufferFull ) { slsaSaveRawMemoryForSimTargetOP ( rtS , "svpwm_inv_ideal_switch_Motor/CurrentsMuxFilter1/Mean1/Model/Transport Delay0" , ( void * * ) ( & rtDW . htnluil54k [ 0 ] ) , ( rtDW . lf1hqp3kgd [ 3 ] << 1 ) * sizeof ( real_T ) , NULL , NULL ) ; } if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { rtDW . ch151dnkqe = rtB . odobza0ien ; } bufferFull = false ; if ( rtDW . asfvwsoqaf [ 1 ] < rtDW . asfvwsoqaf [ 3 ] - 1 ) { rtDW . asfvwsoqaf [ 1 ] ++ ; } else { rtDW . asfvwsoqaf [ 1 ] = 0 ; } if ( rtDW . asfvwsoqaf [ 0 ] == rtDW . asfvwsoqaf [ 1 ] ) { bufferFull = true ; rt_TDelayUpdateTailOrGrowBuf ( & rtDW . asfvwsoqaf [ 3 ] , & rtDW . asfvwsoqaf [ 0 ] , & rtDW . asfvwsoqaf [ 1 ] , & rtDW . asfvwsoqaf [ 2 ] , ssGetT ( rtS ) - rtP . TransportDelay_Delay_gvvsfgtvem , ( real_T * * ) & rtDW . bayevhew2y [ 0 ] , false , false , & rtDW . asfvwsoqaf [ 4 ] ) ; } ( ( real_T * ) rtDW . bayevhew2y [ 0 ] ) [ rtDW . asfvwsoqaf [ 1 ] ] = rtB . fwyauue1r3 ; ( ( real_T * ) rtDW . bayevhew2y [ 0 ] ) [ rtDW . asfvwsoqaf [ 1 ] + rtDW . asfvwsoqaf [ 3 ] ] = ssGetT ( rtS ) ; if ( bufferFull ) { slsaSaveRawMemoryForSimTargetOP ( rtS , "svpwm_inv_ideal_switch_Motor/CurrentsMuxFilter1/Mean/Model/Transport Delay0" , ( void * * ) ( & rtDW . bayevhew2y [ 0 ] ) , ( rtDW . asfvwsoqaf [ 3 ] << 1 ) * sizeof ( real_T ) , NULL , NULL ) ; } if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { rtDW . imtaqygzf4 = rtB . l1db0zw3xd ; } if ( ssIsSampleHit ( rtS , 5 , 0 ) ) { rtDW . myxkp4g3jb += rtP . Integrator_gainval_paibil4hm3 * rtB . desxhsenu1 ; } if ( ssIsSampleHit ( rtS , 4 , 0 ) && ssIsSampleHit ( rtS , 4 , 0 ) ) { rtDW . gcyhq2afeb += rtP . Integrator_gainval * rtB . n4ts4dtcsq ; rtDW . p4cmclm0n5 += rtP . Integrator_gainval_k5jjwwdxok * rtB . akq1ntnmq3 ; } UNUSED_PARAMETER ( tid ) ; } void MdlUpdateTID6 ( int_T tid ) { UNUSED_PARAMETER ( tid ) ; } void MdlDerivatives ( void ) { NeslSimulationData * simulationData ; NeuDiagnosticManager * diagnosticManager ; NeuDiagnosticTree * diagnosticTree ; XDot * _rtXdot ; char * msg ; real_T tmp_p [ 16 ] ; real_T time ; int_T tmp_e [ 5 ] ; int_T is ; boolean_T tmp ; _rtXdot = ( ( XDot * ) ssGetdX ( rtS ) ) ; _rtXdot -> mmcyaey4zw = 0.0 ; _rtXdot -> mmcyaey4zw += rtP . TransferFcn_A * rtX . mmcyaey4zw ; _rtXdot -> mmcyaey4zw += rtB . nlfkewwkrq [ 4 ] ; _rtXdot -> erjd0mhsiq = ( rtB . fj3clsrn1n - rtX . erjd0mhsiq ) * 1000.0 ; simulationData = ( NeslSimulationData * ) rtDW . mjaqu4jcnj ; time = ssGetT ( rtS ) ; simulationData -> mData -> mTime . mN = 1 ; simulationData -> mData -> mTime . mX = & time ; simulationData -> mData -> mContStates . mN = 36 ; simulationData -> mData -> mContStates . mX = & rtX . mmg5sph3io [ 0 ] ; simulationData -> mData -> mDiscStates . mN = 147 ; simulationData -> mData -> mDiscStates . mX = & rtDW . atond0rmxa [ 0 ] ; simulationData -> mData -> mModeVector . mN = 56 ; simulationData -> mData -> mModeVector . mX = & rtDW . c1wtxhepbi [ 0 ] ; tmp = ( ssIsMajorTimeStep ( rtS ) && ssGetRTWSolverInfo ( rtS ) -> foundContZcEvents ) ; simulationData -> mData -> mFoundZcEvents = tmp ; simulationData -> mData -> mHadEvents = false ; simulationData -> mData -> mIsMajorTimeStep = ssIsMajorTimeStep ( rtS ) ; tmp = ( ssGetMdlInfoPtr ( rtS ) -> mdlFlags . solverAssertCheck == 1U ) ; simulationData -> mData -> mIsSolverAssertCheck = tmp ; tmp = ssIsSolverCheckingCIC ( rtS ) ; simulationData -> mData -> mIsSolverCheckingCIC = tmp ; tmp = ssIsSolverComputingJacobian ( rtS ) ; simulationData -> mData -> mIsComputingJacobian = tmp ; simulationData -> mData -> mIsEvaluatingF0 = ( ssGetEvaluatingF0ForJacobian ( rtS ) != 0 ) ; tmp = ssIsSolverRequestingReset ( rtS ) ; simulationData -> mData -> mIsSolverRequestingReset = tmp ; simulationData -> mData -> mIsModeUpdateTimeStep = ssIsModeUpdateTimeStep ( rtS ) ; tmp_e [ 0 ] = 0 ; tmp_p [ 0 ] = rtB . m1glkuwbva [ 0 ] ; tmp_p [ 1 ] = rtB . m1glkuwbva [ 1 ] ; tmp_p [ 2 ] = rtB . m1glkuwbva [ 2 ] ; tmp_p [ 3 ] = rtB . m1glkuwbva [ 3 ] ; tmp_e [ 1 ] = 4 ; tmp_p [ 4 ] = rtB . ipcfdxqbvr [ 0 ] ; tmp_p [ 5 ] = rtB . ipcfdxqbvr [ 1 ] ; tmp_p [ 6 ] = rtB . ipcfdxqbvr [ 2 ] ; tmp_p [ 7 ] = rtB . ipcfdxqbvr [ 3 ] ; tmp_e [ 2 ] = 8 ; tmp_p [ 8 ] = rtB . mpqyczxej3 [ 0 ] ; tmp_p [ 9 ] = rtB . mpqyczxej3 [ 1 ] ; tmp_p [ 10 ] = rtB . mpqyczxej3 [ 2 ] ; tmp_p [ 11 ] = rtB . mpqyczxej3 [ 3 ] ; tmp_e [ 3 ] = 12 ; tmp_p [ 12 ] = rtB . embqhexp1p [ 0 ] ; tmp_p [ 13 ] = rtB . embqhexp1p [ 1 ] ; tmp_p [ 14 ] = rtB . embqhexp1p [ 2 ] ; tmp_p [ 15 ] = rtB . embqhexp1p [ 3 ] ; tmp_e [ 4 ] = 16 ; simulationData -> mData -> mInputValues . mN = 16 ; simulationData -> mData -> mInputValues . mX = & tmp_p [ 0 ] ; simulationData -> mData -> mInputOffsets . mN = 5 ; simulationData -> mData -> mInputOffsets . mX = & tmp_e [ 0 ] ; simulationData -> mData -> mDx . mN = 36 ; simulationData -> mData -> mDx . mX = & _rtXdot -> mmg5sph3io [ 0 ] ; diagnosticManager = ( NeuDiagnosticManager * ) rtDW . lt4h1wfkog ; diagnosticTree = neu_diagnostic_manager_get_initial_tree ( diagnosticManager ) ; is = ne_simulator_method ( ( NeslSimulator * ) rtDW . et4usql3vc , NESL_SIM_DERIVATIVES , simulationData , diagnosticManager ) ; if ( is != 0 ) { tmp = error_buffer_is_empty ( ssGetErrorStatus ( rtS ) ) ; if ( tmp ) { msg = rtw_diagnostics_msg ( diagnosticTree ) ; ssSetErrorStatus ( rtS , msg ) ; } } _rtXdot -> lqcuiwaata = 0.0 ; _rtXdot -> lqcuiwaata += rtP . TransferFcn1_A * rtX . lqcuiwaata ; _rtXdot -> lqcuiwaata += rtB . nlfkewwkrq [ 6 ] ; _rtXdot -> fqujvrhmxc = 0.0 ; _rtXdot -> fqujvrhmxc += rtP . TransferFcn2_A * rtX . fqujvrhmxc ; _rtXdot -> fqujvrhmxc += rtB . nlfkewwkrq [ 7 ] ; _rtXdot -> lvqvgep4z3 = 0.0 ; _rtXdot -> lvqvgep4z3 += rtP . TransferFcn3_A * rtX . lvqvgep4z3 ; _rtXdot -> lvqvgep4z3 += rtB . nlfkewwkrq [ 8 ] ; _rtXdot -> c1dvebixah = rtB . nlfkewwkrq [ 10 ] ; _rtXdot -> bufufyp5jw = rtB . nlfkewwkrq [ 9 ] ; _rtXdot -> nrr4jufios = rtB . nlfkewwkrq [ 11 ] ; _rtXdot -> adzjcfmnhs = 0.0 ; _rtXdot -> adzjcfmnhs += rtP . TransferFcn_A_c1oljm0wuu * rtX . adzjcfmnhs ; _rtXdot -> adzjcfmnhs += rtB . nlfkewwkrq [ 4 ] ; } void MdlProjection ( void ) { } void MdlForcingFunction ( void ) { NeslSimulationData * simulationData ; NeuDiagnosticManager * diagnosticManager ; NeuDiagnosticTree * diagnosticTree ; XDot * _rtXdot ; char * msg ; real_T tmp_p [ 16 ] ; real_T time ; int_T tmp_e [ 5 ] ; int_T is ; boolean_T tmp ; _rtXdot = ( ( XDot * ) ssGetdX ( rtS ) ) ; _rtXdot -> mmcyaey4zw = 0.0 ; _rtXdot -> mmcyaey4zw += rtP . TransferFcn_A * rtX . mmcyaey4zw ; _rtXdot -> mmcyaey4zw += rtB . nlfkewwkrq [ 4 ] ; _rtXdot -> erjd0mhsiq = ( rtB . fj3clsrn1n - rtX . erjd0mhsiq ) * 1000.0 ; simulationData = ( NeslSimulationData * ) rtDW . mjaqu4jcnj ; time = ssGetT ( rtS ) ; simulationData -> mData -> mTime . mN = 1 ; simulationData -> mData -> mTime . mX = & time ; simulationData -> mData -> mContStates . mN = 36 ; simulationData -> mData -> mContStates . mX = & rtX . mmg5sph3io [ 0 ] ; simulationData -> mData -> mDiscStates . mN = 147 ; simulationData -> mData -> mDiscStates . mX = & rtDW . atond0rmxa [ 0 ] ; simulationData -> mData -> mModeVector . mN = 56 ; simulationData -> mData -> mModeVector . mX = & rtDW . c1wtxhepbi [ 0 ] ; tmp = ( ssIsMajorTimeStep ( rtS ) && ssGetRTWSolverInfo ( rtS ) -> foundContZcEvents ) ; simulationData -> mData -> mFoundZcEvents = tmp ; simulationData -> mData -> mHadEvents = false ; simulationData -> mData -> mIsMajorTimeStep = ssIsMajorTimeStep ( rtS ) ; tmp = ( ssGetMdlInfoPtr ( rtS ) -> mdlFlags . solverAssertCheck == 1U ) ; simulationData -> mData -> mIsSolverAssertCheck = tmp ; tmp = ssIsSolverCheckingCIC ( rtS ) ; simulationData -> mData -> mIsSolverCheckingCIC = tmp ; tmp = ssIsSolverComputingJacobian ( rtS ) ; simulationData -> mData -> mIsComputingJacobian = tmp ; simulationData -> mData -> mIsEvaluatingF0 = ( ssGetEvaluatingF0ForJacobian ( rtS ) != 0 ) ; tmp = ssIsSolverRequestingReset ( rtS ) ; simulationData -> mData -> mIsSolverRequestingReset = tmp ; simulationData -> mData -> mIsModeUpdateTimeStep = ssIsModeUpdateTimeStep ( rtS ) ; tmp_e [ 0 ] = 0 ; tmp_p [ 0 ] = rtB . m1glkuwbva [ 0 ] ; tmp_p [ 1 ] = rtB . m1glkuwbva [ 1 ] ; tmp_p [ 2 ] = rtB . m1glkuwbva [ 2 ] ; tmp_p [ 3 ] = rtB . m1glkuwbva [ 3 ] ; tmp_e [ 1 ] = 4 ; tmp_p [ 4 ] = rtB . ipcfdxqbvr [ 0 ] ; tmp_p [ 5 ] = rtB . ipcfdxqbvr [ 1 ] ; tmp_p [ 6 ] = rtB . ipcfdxqbvr [ 2 ] ; tmp_p [ 7 ] = rtB . ipcfdxqbvr [ 3 ] ; tmp_e [ 2 ] = 8 ; tmp_p [ 8 ] = rtB . mpqyczxej3 [ 0 ] ; tmp_p [ 9 ] = rtB . mpqyczxej3 [ 1 ] ; tmp_p [ 10 ] = rtB . mpqyczxej3 [ 2 ] ; tmp_p [ 11 ] = rtB . mpqyczxej3 [ 3 ] ; tmp_e [ 3 ] = 12 ; tmp_p [ 12 ] = rtB . embqhexp1p [ 0 ] ; tmp_p [ 13 ] = rtB . embqhexp1p [ 1 ] ; tmp_p [ 14 ] = rtB . embqhexp1p [ 2 ] ; tmp_p [ 15 ] = rtB . embqhexp1p [ 3 ] ; tmp_e [ 4 ] = 16 ; simulationData -> mData -> mInputValues . mN = 16 ; simulationData -> mData -> mInputValues . mX = & tmp_p [ 0 ] ; simulationData -> mData -> mInputOffsets . mN = 5 ; simulationData -> mData -> mInputOffsets . mX = & tmp_e [ 0 ] ; simulationData -> mData -> mDx . mN = 36 ; simulationData -> mData -> mDx . mX = & _rtXdot -> mmg5sph3io [ 0 ] ; diagnosticManager = ( NeuDiagnosticManager * ) rtDW . lt4h1wfkog ; diagnosticTree = neu_diagnostic_manager_get_initial_tree ( diagnosticManager ) ; is = ne_simulator_method ( ( NeslSimulator * ) rtDW . et4usql3vc , NESL_SIM_FORCINGFUNCTION , simulationData , diagnosticManager ) ; if ( is != 0 ) { tmp = error_buffer_is_empty ( ssGetErrorStatus ( rtS ) ) ; if ( tmp ) { msg = rtw_diagnostics_msg ( diagnosticTree ) ; ssSetErrorStatus ( rtS , msg ) ; } } _rtXdot -> lqcuiwaata = 0.0 ; _rtXdot -> lqcuiwaata += rtP . TransferFcn1_A * rtX . lqcuiwaata ; _rtXdot -> lqcuiwaata += rtB . nlfkewwkrq [ 6 ] ; _rtXdot -> fqujvrhmxc = 0.0 ; _rtXdot -> fqujvrhmxc += rtP . TransferFcn2_A * rtX . fqujvrhmxc ; _rtXdot -> fqujvrhmxc += rtB . nlfkewwkrq [ 7 ] ; _rtXdot -> lvqvgep4z3 = 0.0 ; _rtXdot -> lvqvgep4z3 += rtP . TransferFcn3_A * rtX . lvqvgep4z3 ; _rtXdot -> lvqvgep4z3 += rtB . nlfkewwkrq [ 8 ] ; _rtXdot -> c1dvebixah = rtB . nlfkewwkrq [ 10 ] ; _rtXdot -> bufufyp5jw = rtB . nlfkewwkrq [ 9 ] ; _rtXdot -> nrr4jufios = rtB . nlfkewwkrq [ 11 ] ; _rtXdot -> adzjcfmnhs = 0.0 ; _rtXdot -> adzjcfmnhs += rtP . TransferFcn_A_c1oljm0wuu * rtX . adzjcfmnhs ; _rtXdot -> adzjcfmnhs += rtB . nlfkewwkrq [ 4 ] ; } void MdlMassMatrix ( void ) { NeslSimulationData * simulationData ; NeuDiagnosticManager * diagnosticManager ; NeuDiagnosticTree * diagnosticTree ; char * msg ; real_T tmp_p [ 16 ] ; real_T time ; real_T * tmp_i ; real_T * tmp_m ; int32_T tmp_g ; int_T tmp_e [ 5 ] ; boolean_T tmp ; simulationData = ( NeslSimulationData * ) rtDW . mjaqu4jcnj ; time = ssGetT ( rtS ) ; simulationData -> mData -> mTime . mN = 1 ; simulationData -> mData -> mTime . mX = & time ; simulationData -> mData -> mContStates . mN = 36 ; simulationData -> mData -> mContStates . mX = & rtX . mmg5sph3io [ 0 ] ; simulationData -> mData -> mDiscStates . mN = 147 ; simulationData -> mData -> mDiscStates . mX = & rtDW . atond0rmxa [ 0 ] ; simulationData -> mData -> mModeVector . mN = 56 ; simulationData -> mData -> mModeVector . mX = & rtDW . c1wtxhepbi [ 0 ] ; tmp = ( ssIsMajorTimeStep ( rtS ) && ssGetRTWSolverInfo ( rtS ) -> foundContZcEvents ) ; simulationData -> mData -> mFoundZcEvents = tmp ; simulationData -> mData -> mHadEvents = false ; simulationData -> mData -> mIsMajorTimeStep = ssIsMajorTimeStep ( rtS ) ; tmp = ( ssGetMdlInfoPtr ( rtS ) -> mdlFlags . solverAssertCheck == 1U ) ; simulationData -> mData -> mIsSolverAssertCheck = tmp ; tmp = ssIsSolverCheckingCIC ( rtS ) ; simulationData -> mData -> mIsSolverCheckingCIC = tmp ; tmp = ssIsSolverComputingJacobian ( rtS ) ; simulationData -> mData -> mIsComputingJacobian = tmp ; simulationData -> mData -> mIsEvaluatingF0 = ( ssGetEvaluatingF0ForJacobian ( rtS ) != 0 ) ; tmp = ssIsSolverRequestingReset ( rtS ) ; simulationData -> mData -> mIsSolverRequestingReset = tmp ; simulationData -> mData -> mIsModeUpdateTimeStep = ssIsModeUpdateTimeStep ( rtS ) ; tmp_e [ 0 ] = 0 ; tmp_p [ 0 ] = rtB . m1glkuwbva [ 0 ] ; tmp_p [ 1 ] = rtB . m1glkuwbva [ 1 ] ; tmp_p [ 2 ] = rtB . m1glkuwbva [ 2 ] ; tmp_p [ 3 ] = rtB . m1glkuwbva [ 3 ] ; tmp_e [ 1 ] = 4 ; tmp_p [ 4 ] = rtB . ipcfdxqbvr [ 0 ] ; tmp_p [ 5 ] = rtB . ipcfdxqbvr [ 1 ] ; tmp_p [ 6 ] = rtB . ipcfdxqbvr [ 2 ] ; tmp_p [ 7 ] = rtB . ipcfdxqbvr [ 3 ] ; tmp_e [ 2 ] = 8 ; tmp_p [ 8 ] = rtB . mpqyczxej3 [ 0 ] ; tmp_p [ 9 ] = rtB . mpqyczxej3 [ 1 ] ; tmp_p [ 10 ] = rtB . mpqyczxej3 [ 2 ] ; tmp_p [ 11 ] = rtB . mpqyczxej3 [ 3 ] ; tmp_e [ 3 ] = 12 ; tmp_p [ 12 ] = rtB . embqhexp1p [ 0 ] ; tmp_p [ 13 ] = rtB . embqhexp1p [ 1 ] ; tmp_p [ 14 ] = rtB . embqhexp1p [ 2 ] ; tmp_p [ 15 ] = rtB . embqhexp1p [ 3 ] ; tmp_e [ 4 ] = 16 ; simulationData -> mData -> mInputValues . mN = 16 ; simulationData -> mData -> mInputValues . mX = & tmp_p [ 0 ] ; simulationData -> mData -> mInputOffsets . mN = 5 ; simulationData -> mData -> mInputOffsets . mX = & tmp_e [ 0 ] ; tmp_i = ssGetMassMatrixPr ( rtS ) ; tmp_m = double_pointer_shift ( tmp_i , rtDW . pyuf5pxogp ) ; simulationData -> mData -> mMassMatrixPr . mN = 7 ; simulationData -> mData -> mMassMatrixPr . mX = tmp_m ; diagnosticManager = ( NeuDiagnosticManager * ) rtDW . lt4h1wfkog ; diagnosticTree = neu_diagnostic_manager_get_initial_tree ( diagnosticManager ) ; tmp_g = ne_simulator_method ( ( NeslSimulator * ) rtDW . et4usql3vc , NESL_SIM_MASSMATRIX , simulationData , diagnosticManager ) ; if ( tmp_g != 0 ) { tmp = error_buffer_is_empty ( ssGetErrorStatus ( rtS ) ) ; if ( tmp ) { msg = rtw_diagnostics_msg ( diagnosticTree ) ; ssSetErrorStatus ( rtS , msg ) ; } } } void MdlZeroCrossings ( void ) { NeslSimulationData * simulationData ; NeuDiagnosticManager * diagnosticManager ; NeuDiagnosticTree * diagnosticTree ; ZCV * _rtZCSV ; char * msg ; real_T tmp_p [ 16 ] ; real_T time ; int32_T tmp_i ; int_T tmp_e [ 5 ] ; boolean_T tmp ; _rtZCSV = ( ( ZCV * ) ssGetSolverZcSignalVector ( rtS ) ) ; _rtZCSV -> mfaaqblhul = rtB . ekk11nkuz3 ; simulationData = ( NeslSimulationData * ) rtDW . mjaqu4jcnj ; time = ssGetT ( rtS ) ; simulationData -> mData -> mTime . mN = 1 ; simulationData -> mData -> mTime . mX = & time ; simulationData -> mData -> mContStates . mN = 36 ; simulationData -> mData -> mContStates . mX = & rtX . mmg5sph3io [ 0 ] ; simulationData -> mData -> mDiscStates . mN = 147 ; simulationData -> mData -> mDiscStates . mX = & rtDW . atond0rmxa [ 0 ] ; simulationData -> mData -> mModeVector . mN = 56 ; simulationData -> mData -> mModeVector . mX = & rtDW . c1wtxhepbi [ 0 ] ; tmp = ( ssIsMajorTimeStep ( rtS ) && ssGetRTWSolverInfo ( rtS ) -> foundContZcEvents ) ; simulationData -> mData -> mFoundZcEvents = tmp ; simulationData -> mData -> mHadEvents = false ; simulationData -> mData -> mIsMajorTimeStep = ssIsMajorTimeStep ( rtS ) ; tmp = ( ssGetMdlInfoPtr ( rtS ) -> mdlFlags . solverAssertCheck == 1U ) ; simulationData -> mData -> mIsSolverAssertCheck = tmp ; tmp = ssIsSolverCheckingCIC ( rtS ) ; simulationData -> mData -> mIsSolverCheckingCIC = tmp ; tmp = ssIsSolverComputingJacobian ( rtS ) ; simulationData -> mData -> mIsComputingJacobian = tmp ; simulationData -> mData -> mIsEvaluatingF0 = ( ssGetEvaluatingF0ForJacobian ( rtS ) != 0 ) ; tmp = ssIsSolverRequestingReset ( rtS ) ; simulationData -> mData -> mIsSolverRequestingReset = tmp ; simulationData -> mData -> mIsModeUpdateTimeStep = ssIsModeUpdateTimeStep ( rtS ) ; tmp_e [ 0 ] = 0 ; tmp_p [ 0 ] = rtB . m1glkuwbva [ 0 ] ; tmp_p [ 1 ] = rtB . m1glkuwbva [ 1 ] ; tmp_p [ 2 ] = rtB . m1glkuwbva [ 2 ] ; tmp_p [ 3 ] = rtB . m1glkuwbva [ 3 ] ; tmp_e [ 1 ] = 4 ; tmp_p [ 4 ] = rtB . ipcfdxqbvr [ 0 ] ; tmp_p [ 5 ] = rtB . ipcfdxqbvr [ 1 ] ; tmp_p [ 6 ] = rtB . ipcfdxqbvr [ 2 ] ; tmp_p [ 7 ] = rtB . ipcfdxqbvr [ 3 ] ; tmp_e [ 2 ] = 8 ; tmp_p [ 8 ] = rtB . mpqyczxej3 [ 0 ] ; tmp_p [ 9 ] = rtB . mpqyczxej3 [ 1 ] ; tmp_p [ 10 ] = rtB . mpqyczxej3 [ 2 ] ; tmp_p [ 11 ] = rtB . mpqyczxej3 [ 3 ] ; tmp_e [ 3 ] = 12 ; tmp_p [ 12 ] = rtB . embqhexp1p [ 0 ] ; tmp_p [ 13 ] = rtB . embqhexp1p [ 1 ] ; tmp_p [ 14 ] = rtB . embqhexp1p [ 2 ] ; tmp_p [ 15 ] = rtB . embqhexp1p [ 3 ] ; tmp_e [ 4 ] = 16 ; simulationData -> mData -> mInputValues . mN = 16 ; simulationData -> mData -> mInputValues . mX = & tmp_p [ 0 ] ; simulationData -> mData -> mInputOffsets . mN = 5 ; simulationData -> mData -> mInputOffsets . mX = & tmp_e [ 0 ] ; simulationData -> mData -> mNonSampledZCs . mN = 56 ; simulationData -> mData -> mNonSampledZCs . mX = & _rtZCSV -> nato2lossk ; diagnosticManager = ( NeuDiagnosticManager * ) rtDW . lt4h1wfkog ; diagnosticTree = neu_diagnostic_manager_get_initial_tree ( diagnosticManager ) ; tmp_i = ne_simulator_method ( ( NeslSimulator * ) rtDW . et4usql3vc , NESL_SIM_ZEROCROSSINGS , simulationData , diagnosticManager ) ; if ( tmp_i != 0 ) { tmp = error_buffer_is_empty ( ssGetErrorStatus ( rtS ) ) ; if ( tmp ) { msg = rtw_diagnostics_msg ( diagnosticTree ) ; ssSetErrorStatus ( rtS , msg ) ; } } _rtZCSV -> aug0vzo5ho = rtB . bpu0xfzkw1 - rtP . Constant1_Value_bvfdufyota ; _rtZCSV -> da5uztl11g = rtB . fn0xsynz42 - rtP . Constant7_Value ; _rtZCSV -> agtb0l5koy = rtB . f5zsaldpbf - rtP . Constant11_Value ; _rtZCSV -> eottwpkbza = ssGetT ( rtS ) - rtP . Ramp_start ; _rtZCSV -> hy1efdlgdz = ssGetT ( rtS ) - rtP . Ramp1_start ; } void MdlTerminate ( void ) { neu_destroy_diagnostic_manager ( ( NeuDiagnosticManager * ) rtDW . lt4h1wfkog ) ; nesl_destroy_simulation_data ( ( NeslSimulationData * ) rtDW . mjaqu4jcnj ) ; nesl_erase_simulator ( "svpwm_inv_ideal_switch_Motor/Solver Configuration1_1" ) ; nesl_destroy_registry ( ) ; neu_destroy_diagnostic_manager ( ( NeuDiagnosticManager * ) rtDW . h3xczpc1e2 ) ; nesl_destroy_simulation_data ( ( NeslSimulationData * ) rtDW . oxh0jmsh2a ) ; nesl_erase_simulator ( "svpwm_inv_ideal_switch_Motor/Solver Configuration1_1" ) ; nesl_destroy_registry ( ) ; if ( rtDW . lhset4od0v [ 0 ] != NULL ) { free ( rtDW . lhset4od0v [ 0 ] ) ; } if ( rtDW . htnluil54k [ 0 ] != NULL ) { free ( rtDW . htnluil54k [ 0 ] ) ; } if ( rtDW . bayevhew2y [ 0 ] != NULL ) { free ( rtDW . bayevhew2y [ 0 ] ) ; } } static void mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( mxArray * destArray , mwIndex i , int j , const void * srcData , size_t numBytes ) ; static void mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( mxArray * destArray , mwIndex i , int j , const void * srcData , size_t numBytes ) { mxArray * newArray = mxCreateUninitNumericMatrix ( ( size_t ) 1 , numBytes , mxUINT8_CLASS , mxREAL ) ; memcpy ( ( uint8_T * ) mxGetData ( newArray ) , ( const uint8_T * ) srcData , numBytes ) ; mxSetFieldByNumber ( destArray , i , j , newArray ) ; } static void mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( void * destData , const mxArray * srcArray , mwIndex i , int j , size_t numBytes ) ; static void mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( void * destData , const mxArray * srcArray , mwIndex i , int j , size_t numBytes ) { memcpy ( ( uint8_T * ) destData , ( const uint8_T * ) mxGetData ( mxGetFieldByNumber ( srcArray , i , j ) ) , numBytes ) ; } static void mr_svpwm_inv_ideal_switch_Motor_cacheBitFieldToMxArray ( mxArray * destArray , mwIndex i , int j , uint_T bitVal ) ; static void mr_svpwm_inv_ideal_switch_Motor_cacheBitFieldToMxArray ( mxArray * destArray , mwIndex i , int j , uint_T bitVal ) { mxSetFieldByNumber ( destArray , i , j , mxCreateDoubleScalar ( ( real_T ) bitVal ) ) ; } static uint_T mr_svpwm_inv_ideal_switch_Motor_extractBitFieldFromMxArray ( const mxArray * srcArray , mwIndex i , int j , uint_T numBits ) ; static uint_T mr_svpwm_inv_ideal_switch_Motor_extractBitFieldFromMxArray ( const mxArray * srcArray , mwIndex i , int j , uint_T numBits ) { const uint_T varVal = ( uint_T ) mxGetScalar ( mxGetFieldByNumber ( srcArray , i , j ) ) ; return varVal & ( ( 1u << numBits ) - 1u ) ; } static void mr_svpwm_inv_ideal_switch_Motor_cacheDataToMxArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , const void * srcData , size_t numBytes ) ; static void mr_svpwm_inv_ideal_switch_Motor_cacheDataToMxArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , const void * srcData , size_t numBytes ) { uint8_T * varData = ( uint8_T * ) mxGetData ( mxGetFieldByNumber ( destArray , i , j ) ) ; memcpy ( ( uint8_T * ) & varData [ offset * numBytes ] , ( const uint8_T * ) srcData , numBytes ) ; } static void mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArrayWithOffset ( void * destData , const mxArray * srcArray , mwIndex i , int j , mwIndex offset , size_t numBytes ) ; static void mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArrayWithOffset ( void * destData , const mxArray * srcArray , mwIndex i , int j , mwIndex offset , size_t numBytes ) { const uint8_T * varData = ( const uint8_T * ) mxGetData ( mxGetFieldByNumber ( srcArray , i , j ) ) ; memcpy ( ( uint8_T * ) destData , ( const uint8_T * ) & varData [ offset * numBytes ] , numBytes ) ; } static void mr_svpwm_inv_ideal_switch_Motor_cacheBitFieldToCellArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , uint_T fieldVal ) ; static void mr_svpwm_inv_ideal_switch_Motor_cacheBitFieldToCellArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , uint_T fieldVal ) { mxSetCell ( mxGetFieldByNumber ( destArray , i , j ) , offset , mxCreateDoubleScalar ( ( real_T ) fieldVal ) ) ; } static uint_T mr_svpwm_inv_ideal_switch_Motor_extractBitFieldFromCellArrayWithOffset ( const mxArray * srcArray , mwIndex i , int j , mwIndex offset , uint_T numBits ) ; static uint_T mr_svpwm_inv_ideal_switch_Motor_extractBitFieldFromCellArrayWithOffset ( const mxArray * srcArray , mwIndex i , int j , mwIndex offset , uint_T numBits ) { const uint_T fieldVal = ( uint_T ) mxGetScalar ( mxGetCell ( mxGetFieldByNumber ( srcArray , i , j ) , offset ) ) ; return fieldVal & ( ( 1u << numBits ) - 1u ) ; } mxArray * mr_svpwm_inv_ideal_switch_Motor_GetDWork ( ) { static const char_T * ssDWFieldNames [ 3 ] = { "rtB" , "rtDW" , "rtPrevZCX" , } ; mxArray * ssDW = mxCreateStructMatrix ( 1 , 1 , 3 , ssDWFieldNames ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( ssDW , 0 , 0 , ( const void * ) & ( rtB ) , sizeof ( rtB ) ) ; { static const char_T * rtdwDataFieldNames [ 65 ] = { "rtDW.p2newwshb2" , "rtDW.p1eaxc4si3" , "rtDW.fvjpifmnqp" , "rtDW.afz1wmfwwl" , "rtDW.l311fk1wdw" , "rtDW.lvtmdk5pzk" , "rtDW.okewh4umdj" , "rtDW.pzb0hgihqm" , "rtDW.kr2nbusf3i" , "rtDW.liqja2sob3" , "rtDW.inzd25bki4" , "rtDW.hz3nw5alev" , "rtDW.atond0rmxa" , "rtDW.myxkp4g3jb" , "rtDW.gcyhq2afeb" , "rtDW.p4cmclm0n5" , "rtDW.esszafb052" , "rtDW.nke0o0oxmj" , "rtDW.amdqnbpotw" , "rtDW.fvqqusvlbd" , "rtDW.ch151dnkqe" , "rtDW.imtaqygzf4" , "rtDW.jmydjkcywd" , "rtDW.an2k1o2b34" , "rtDW.czk0zyr4wh" , "rtDW.e0jxwlk51j" , "rtDW.lohwd1ejop" , "rtDW.fwnd4bigmd" , "rtDW.apb44q1alb" , "rtDW.lj0scfk3vh" , "rtDW.b2c3cqi0k1" , "rtDW.b4jd5d00a5" , "rtDW.mimt35h5ox" , "rtDW.c1wtxhepbi" , "rtDW.iw1wautste" , "rtDW.pgnkj0dpye" , "rtDW.lf1hqp3kgd" , "rtDW.asfvwsoqaf" , "rtDW.l0rt05nc5w" , "rtDW.gnwzr0jyb5" , "rtDW.dj01vpxxe4" , "rtDW.pyuf5pxogp" , "rtDW.mgelhzivq0" , "rtDW.kxqvqgnnqm" , "rtDW.mm0b0eefph" , "rtDW.dmaj1bab4k" , "rtDW.ohmbboa034" , "rtDW.lzwswludg5" , "rtDW.ee03va2m5d" , "rtDW.lm2wj3hxgc" , "rtDW.pstpl3h2q2" , "rtDW.nojfuzuk1p" , "rtDW.hag3q5jt2e" , "rtDW.p0nt00k2jv" , "rtDW.ewzwsaruv2" , "rtDW.gubchl0bkg" , "rtDW.ismih1kb3k" , "rtDW.ea4lnv1swv" , "rtDW.j1n4b2y2es" , "rtDW.k3a1xzecbk" , "rtDW.ll5n1f2emr" , "rtDW.ltlrw2hvbj" , "rtDW.pf125dsvmu" , "rtDW.abosh0vgit" , "rtDW.cgbt3rljof" , } ; mxArray * rtdwData = mxCreateStructMatrix ( 1 , 1 , 65 , rtdwDataFieldNames ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 0 , ( const void * ) & ( rtDW . p2newwshb2 ) , sizeof ( rtDW . p2newwshb2 ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 1 , ( const void * ) & ( rtDW . p1eaxc4si3 ) , sizeof ( rtDW . p1eaxc4si3 ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 2 , ( const void * ) & ( rtDW . fvjpifmnqp ) , sizeof ( rtDW . fvjpifmnqp ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 3 , ( const void * ) & ( rtDW . afz1wmfwwl ) , sizeof ( rtDW . afz1wmfwwl ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 4 , ( const void * ) & ( rtDW . l311fk1wdw ) , sizeof ( rtDW . l311fk1wdw ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 5 , ( const void * ) & ( rtDW . lvtmdk5pzk ) , sizeof ( rtDW . lvtmdk5pzk ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 6 , ( const void * ) & ( rtDW . okewh4umdj ) , sizeof ( rtDW . okewh4umdj ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 7 , ( const void * ) & ( rtDW . pzb0hgihqm ) , sizeof ( rtDW . pzb0hgihqm ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 8 , ( const void * ) & ( rtDW . kr2nbusf3i ) , sizeof ( rtDW . kr2nbusf3i ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 9 , ( const void * ) & ( rtDW . liqja2sob3 ) , sizeof ( rtDW . liqja2sob3 ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 10 , ( const void * ) & ( rtDW . inzd25bki4 ) , sizeof ( rtDW . inzd25bki4 ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 11 , ( const void * ) & ( rtDW . hz3nw5alev ) , sizeof ( rtDW . hz3nw5alev ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 12 , ( const void * ) & ( rtDW . atond0rmxa ) , sizeof ( rtDW . atond0rmxa ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 13 , ( const void * ) & ( rtDW . myxkp4g3jb ) , sizeof ( rtDW . myxkp4g3jb ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 14 , ( const void * ) & ( rtDW . gcyhq2afeb ) , sizeof ( rtDW . gcyhq2afeb ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 15 , ( const void * ) & ( rtDW . p4cmclm0n5 ) , sizeof ( rtDW . p4cmclm0n5 ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 16 , ( const void * ) & ( rtDW . esszafb052 ) , sizeof ( rtDW . esszafb052 ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 17 , ( const void * ) & ( rtDW . nke0o0oxmj ) , sizeof ( rtDW . nke0o0oxmj ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 18 , ( const void * ) & ( rtDW . amdqnbpotw ) , sizeof ( rtDW . amdqnbpotw ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 19 , ( const void * ) & ( rtDW . fvqqusvlbd ) , sizeof ( rtDW . fvqqusvlbd ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 20 , ( const void * ) & ( rtDW . ch151dnkqe ) , sizeof ( rtDW . ch151dnkqe ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 21 , ( const void * ) & ( rtDW . imtaqygzf4 ) , sizeof ( rtDW . imtaqygzf4 ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 22 , ( const void * ) & ( rtDW . jmydjkcywd ) , sizeof ( rtDW . jmydjkcywd ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 23 , ( const void * ) & ( rtDW . an2k1o2b34 ) , sizeof ( rtDW . an2k1o2b34 ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 24 , ( const void * ) & ( rtDW . czk0zyr4wh ) , sizeof ( rtDW . czk0zyr4wh ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 25 , ( const void * ) & ( rtDW . e0jxwlk51j ) , sizeof ( rtDW . e0jxwlk51j ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 26 , ( const void * ) & ( rtDW . lohwd1ejop ) , sizeof ( rtDW . lohwd1ejop ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 27 , ( const void * ) & ( rtDW . fwnd4bigmd ) , sizeof ( rtDW . fwnd4bigmd ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 28 , ( const void * ) & ( rtDW . apb44q1alb ) , sizeof ( rtDW . apb44q1alb ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 29 , ( const void * ) & ( rtDW . lj0scfk3vh ) , sizeof ( rtDW . lj0scfk3vh ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 30 , ( const void * ) & ( rtDW . b2c3cqi0k1 ) , sizeof ( rtDW . b2c3cqi0k1 ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 31 , ( const void * ) & ( rtDW . b4jd5d00a5 ) , sizeof ( rtDW . b4jd5d00a5 ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 32 , ( const void * ) & ( rtDW . mimt35h5ox ) , sizeof ( rtDW . mimt35h5ox ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 33 , ( const void * ) & ( rtDW . c1wtxhepbi ) , sizeof ( rtDW . c1wtxhepbi ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 34 , ( const void * ) & ( rtDW . iw1wautste ) , sizeof ( rtDW . iw1wautste ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 35 , ( const void * ) & ( rtDW . pgnkj0dpye ) , sizeof ( rtDW . pgnkj0dpye ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 36 , ( const void * ) & ( rtDW . lf1hqp3kgd ) , sizeof ( rtDW . lf1hqp3kgd ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 37 , ( const void * ) & ( rtDW . asfvwsoqaf ) , sizeof ( rtDW . asfvwsoqaf ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 38 , ( const void * ) & ( rtDW . l0rt05nc5w ) , sizeof ( rtDW . l0rt05nc5w ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 39 , ( const void * ) & ( rtDW . gnwzr0jyb5 ) , sizeof ( rtDW . gnwzr0jyb5 ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 40 , ( const void * ) & ( rtDW . dj01vpxxe4 ) , sizeof ( rtDW . dj01vpxxe4 ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 41 , ( const void * ) & ( rtDW . pyuf5pxogp ) , sizeof ( rtDW . pyuf5pxogp ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 42 , ( const void * ) & ( rtDW . mgelhzivq0 ) , sizeof ( rtDW . mgelhzivq0 ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 43 , ( const void * ) & ( rtDW . kxqvqgnnqm ) , sizeof ( rtDW . kxqvqgnnqm ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 44 , ( const void * ) & ( rtDW . mm0b0eefph ) , sizeof ( rtDW . mm0b0eefph ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 45 , ( const void * ) & ( rtDW . dmaj1bab4k ) , sizeof ( rtDW . dmaj1bab4k ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 46 , ( const void * ) & ( rtDW . ohmbboa034 ) , sizeof ( rtDW . ohmbboa034 ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 47 , ( const void * ) & ( rtDW . lzwswludg5 ) , sizeof ( rtDW . lzwswludg5 ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 48 , ( const void * ) & ( rtDW . ee03va2m5d ) , sizeof ( rtDW . ee03va2m5d ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 49 , ( const void * ) & ( rtDW . lm2wj3hxgc ) , sizeof ( rtDW . lm2wj3hxgc ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 50 , ( const void * ) & ( rtDW . pstpl3h2q2 ) , sizeof ( rtDW . pstpl3h2q2 ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 51 , ( const void * ) & ( rtDW . nojfuzuk1p ) , sizeof ( rtDW . nojfuzuk1p ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 52 , ( const void * ) & ( rtDW . hag3q5jt2e ) , sizeof ( rtDW . hag3q5jt2e ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 53 , ( const void * ) & ( rtDW . p0nt00k2jv ) , sizeof ( rtDW . p0nt00k2jv ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 54 , ( const void * ) & ( rtDW . ewzwsaruv2 ) , sizeof ( rtDW . ewzwsaruv2 ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 55 , ( const void * ) & ( rtDW . gubchl0bkg ) , sizeof ( rtDW . gubchl0bkg ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 56 , ( const void * ) & ( rtDW . ismih1kb3k ) , sizeof ( rtDW . ismih1kb3k ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 57 , ( const void * ) & ( rtDW . ea4lnv1swv ) , sizeof ( rtDW . ea4lnv1swv ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 58 , ( const void * ) & ( rtDW . j1n4b2y2es ) , sizeof ( rtDW . j1n4b2y2es ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 59 , ( const void * ) & ( rtDW . k3a1xzecbk ) , sizeof ( rtDW . k3a1xzecbk ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 60 , ( const void * ) & ( rtDW . ll5n1f2emr ) , sizeof ( rtDW . ll5n1f2emr ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 61 , ( const void * ) & ( rtDW . ltlrw2hvbj ) , sizeof ( rtDW . ltlrw2hvbj ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 62 , ( const void * ) & ( rtDW . pf125dsvmu ) , sizeof ( rtDW . pf125dsvmu ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 63 , ( const void * ) & ( rtDW . abosh0vgit ) , sizeof ( rtDW . abosh0vgit ) ) ; mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( rtdwData , 0 , 64 , ( const void * ) & ( rtDW . cgbt3rljof ) , sizeof ( rtDW . cgbt3rljof ) ) ; mxSetFieldByNumber ( ssDW , 0 , 1 , rtdwData ) ; } mr_svpwm_inv_ideal_switch_Motor_cacheDataAsMxArray ( ssDW , 0 , 2 , ( const void * ) & ( rtPrevZCX ) , sizeof ( rtPrevZCX ) ) ; return ssDW ; } void mr_svpwm_inv_ideal_switch_Motor_SetDWork ( const mxArray * ssDW ) { ( void ) ssDW ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtB ) , ssDW , 0 , 0 , sizeof ( rtB ) ) ; { const mxArray * rtdwData = mxGetFieldByNumber ( ssDW , 0 , 1 ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . p2newwshb2 ) , rtdwData , 0 , 0 , sizeof ( rtDW . p2newwshb2 ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . p1eaxc4si3 ) , rtdwData , 0 , 1 , sizeof ( rtDW . p1eaxc4si3 ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . fvjpifmnqp ) , rtdwData , 0 , 2 , sizeof ( rtDW . fvjpifmnqp ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . afz1wmfwwl ) , rtdwData , 0 , 3 , sizeof ( rtDW . afz1wmfwwl ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . l311fk1wdw ) , rtdwData , 0 , 4 , sizeof ( rtDW . l311fk1wdw ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . lvtmdk5pzk ) , rtdwData , 0 , 5 , sizeof ( rtDW . lvtmdk5pzk ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . okewh4umdj ) , rtdwData , 0 , 6 , sizeof ( rtDW . okewh4umdj ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . pzb0hgihqm ) , rtdwData , 0 , 7 , sizeof ( rtDW . pzb0hgihqm ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . kr2nbusf3i ) , rtdwData , 0 , 8 , sizeof ( rtDW . kr2nbusf3i ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . liqja2sob3 ) , rtdwData , 0 , 9 , sizeof ( rtDW . liqja2sob3 ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . inzd25bki4 ) , rtdwData , 0 , 10 , sizeof ( rtDW . inzd25bki4 ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . hz3nw5alev ) , rtdwData , 0 , 11 , sizeof ( rtDW . hz3nw5alev ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . atond0rmxa ) , rtdwData , 0 , 12 , sizeof ( rtDW . atond0rmxa ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . myxkp4g3jb ) , rtdwData , 0 , 13 , sizeof ( rtDW . myxkp4g3jb ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . gcyhq2afeb ) , rtdwData , 0 , 14 , sizeof ( rtDW . gcyhq2afeb ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . p4cmclm0n5 ) , rtdwData , 0 , 15 , sizeof ( rtDW . p4cmclm0n5 ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . esszafb052 ) , rtdwData , 0 , 16 , sizeof ( rtDW . esszafb052 ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . nke0o0oxmj ) , rtdwData , 0 , 17 , sizeof ( rtDW . nke0o0oxmj ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . amdqnbpotw ) , rtdwData , 0 , 18 , sizeof ( rtDW . amdqnbpotw ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . fvqqusvlbd ) , rtdwData , 0 , 19 , sizeof ( rtDW . fvqqusvlbd ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . ch151dnkqe ) , rtdwData , 0 , 20 , sizeof ( rtDW . ch151dnkqe ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . imtaqygzf4 ) , rtdwData , 0 , 21 , sizeof ( rtDW . imtaqygzf4 ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . jmydjkcywd ) , rtdwData , 0 , 22 , sizeof ( rtDW . jmydjkcywd ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . an2k1o2b34 ) , rtdwData , 0 , 23 , sizeof ( rtDW . an2k1o2b34 ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . czk0zyr4wh ) , rtdwData , 0 , 24 , sizeof ( rtDW . czk0zyr4wh ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . e0jxwlk51j ) , rtdwData , 0 , 25 , sizeof ( rtDW . e0jxwlk51j ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . lohwd1ejop ) , rtdwData , 0 , 26 , sizeof ( rtDW . lohwd1ejop ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . fwnd4bigmd ) , rtdwData , 0 , 27 , sizeof ( rtDW . fwnd4bigmd ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . apb44q1alb ) , rtdwData , 0 , 28 , sizeof ( rtDW . apb44q1alb ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . lj0scfk3vh ) , rtdwData , 0 , 29 , sizeof ( rtDW . lj0scfk3vh ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . b2c3cqi0k1 ) , rtdwData , 0 , 30 , sizeof ( rtDW . b2c3cqi0k1 ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . b4jd5d00a5 ) , rtdwData , 0 , 31 , sizeof ( rtDW . b4jd5d00a5 ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . mimt35h5ox ) , rtdwData , 0 , 32 , sizeof ( rtDW . mimt35h5ox ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . c1wtxhepbi ) , rtdwData , 0 , 33 , sizeof ( rtDW . c1wtxhepbi ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . iw1wautste ) , rtdwData , 0 , 34 , sizeof ( rtDW . iw1wautste ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . pgnkj0dpye ) , rtdwData , 0 , 35 , sizeof ( rtDW . pgnkj0dpye ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . lf1hqp3kgd ) , rtdwData , 0 , 36 , sizeof ( rtDW . lf1hqp3kgd ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . asfvwsoqaf ) , rtdwData , 0 , 37 , sizeof ( rtDW . asfvwsoqaf ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . l0rt05nc5w ) , rtdwData , 0 , 38 , sizeof ( rtDW . l0rt05nc5w ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . gnwzr0jyb5 ) , rtdwData , 0 , 39 , sizeof ( rtDW . gnwzr0jyb5 ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . dj01vpxxe4 ) , rtdwData , 0 , 40 , sizeof ( rtDW . dj01vpxxe4 ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . pyuf5pxogp ) , rtdwData , 0 , 41 , sizeof ( rtDW . pyuf5pxogp ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . mgelhzivq0 ) , rtdwData , 0 , 42 , sizeof ( rtDW . mgelhzivq0 ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . kxqvqgnnqm ) , rtdwData , 0 , 43 , sizeof ( rtDW . kxqvqgnnqm ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . mm0b0eefph ) , rtdwData , 0 , 44 , sizeof ( rtDW . mm0b0eefph ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . dmaj1bab4k ) , rtdwData , 0 , 45 , sizeof ( rtDW . dmaj1bab4k ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . ohmbboa034 ) , rtdwData , 0 , 46 , sizeof ( rtDW . ohmbboa034 ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . lzwswludg5 ) , rtdwData , 0 , 47 , sizeof ( rtDW . lzwswludg5 ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . ee03va2m5d ) , rtdwData , 0 , 48 , sizeof ( rtDW . ee03va2m5d ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . lm2wj3hxgc ) , rtdwData , 0 , 49 , sizeof ( rtDW . lm2wj3hxgc ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . pstpl3h2q2 ) , rtdwData , 0 , 50 , sizeof ( rtDW . pstpl3h2q2 ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . nojfuzuk1p ) , rtdwData , 0 , 51 , sizeof ( rtDW . nojfuzuk1p ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . hag3q5jt2e ) , rtdwData , 0 , 52 , sizeof ( rtDW . hag3q5jt2e ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . p0nt00k2jv ) , rtdwData , 0 , 53 , sizeof ( rtDW . p0nt00k2jv ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . ewzwsaruv2 ) , rtdwData , 0 , 54 , sizeof ( rtDW . ewzwsaruv2 ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . gubchl0bkg ) , rtdwData , 0 , 55 , sizeof ( rtDW . gubchl0bkg ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . ismih1kb3k ) , rtdwData , 0 , 56 , sizeof ( rtDW . ismih1kb3k ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . ea4lnv1swv ) , rtdwData , 0 , 57 , sizeof ( rtDW . ea4lnv1swv ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . j1n4b2y2es ) , rtdwData , 0 , 58 , sizeof ( rtDW . j1n4b2y2es ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . k3a1xzecbk ) , rtdwData , 0 , 59 , sizeof ( rtDW . k3a1xzecbk ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . ll5n1f2emr ) , rtdwData , 0 , 60 , sizeof ( rtDW . ll5n1f2emr ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . ltlrw2hvbj ) , rtdwData , 0 , 61 , sizeof ( rtDW . ltlrw2hvbj ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . pf125dsvmu ) , rtdwData , 0 , 62 , sizeof ( rtDW . pf125dsvmu ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . abosh0vgit ) , rtdwData , 0 , 63 , sizeof ( rtDW . abosh0vgit ) ) ; mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtDW . cgbt3rljof ) , rtdwData , 0 , 64 , sizeof ( rtDW . cgbt3rljof ) ) ; } mr_svpwm_inv_ideal_switch_Motor_restoreDataFromMxArray ( ( void * ) & ( rtPrevZCX ) , ssDW , 0 , 2 , sizeof ( rtPrevZCX ) ) ; } mxArray * mr_svpwm_inv_ideal_switch_Motor_GetSimStateDisallowedBlocks ( ) { mxArray * data = mxCreateCellMatrix ( 10 , 3 ) ; mwIndex subs [ 2 ] , offset ; { static const char_T * blockType [ 10 ] = { "SimscapeRtp" , "SimscapeExecutionBlock" , "SimscapeExecutionBlock" , "Scope" , "Scope" , "Scope" , "Scope" , "Scope" , "Scope" , "Scope" , } ; static const char_T * blockPath [ 10 ] = { "svpwm_inv_ideal_switch_Motor/Solver Configuration1/RTP_1" , "svpwm_inv_ideal_switch_Motor/Solver Configuration1/EVAL_KEY/STATE_1" , "svpwm_inv_ideal_switch_Motor/Solver Configuration1/EVAL_KEY/OUTPUT_1_0" , "svpwm_inv_ideal_switch_Motor/Scope" , "svpwm_inv_ideal_switch_Motor/Scope1" , "svpwm_inv_ideal_switch_Motor/Scope11" , "svpwm_inv_ideal_switch_Motor/Scope3" , "svpwm_inv_ideal_switch_Motor/Scope4" , "svpwm_inv_ideal_switch_Motor/Scope5" , "svpwm_inv_ideal_switch_Motor/Scope6" , } ; static const int reason [ 10 ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , } ; for ( subs [ 0 ] = 0 ; subs [ 0 ] < 10 ; ++ ( subs [ 0 ] ) ) { subs [ 1 ] = 0 ; offset = mxCalcSingleSubscript ( data , 2 , subs ) ; mxSetCell ( data , offset , mxCreateString ( blockType [ subs [ 0 ] ] ) ) ; subs [ 1 ] = 1 ; offset = mxCalcSingleSubscript ( data , 2 , subs ) ; mxSetCell ( data , offset , mxCreateString ( blockPath [ subs [ 0 ] ] ) ) ; subs [ 1 ] = 2 ; offset = mxCalcSingleSubscript ( data , 2 , subs ) ; mxSetCell ( data , offset , mxCreateDoubleScalar ( ( real_T ) reason [ subs [ 0 ] ] ) ) ; } } return data ; } void MdlInitializeSizes ( void ) { ssSetNumContStates ( rtS , 45 ) ; ssSetNumPeriodicContStates ( rtS , 0 ) ; ssSetNumY ( rtS , 0 ) ; ssSetNumU ( rtS , 0 ) ; ssSetDirectFeedThrough ( rtS , 0 ) ; ssSetNumSampleTimes ( rtS , 6 ) ; ssSetNumBlocks ( rtS , 429 ) ; ssSetNumBlockIO ( rtS , 88 ) ; ssSetNumBlockParams ( rtS , 155 ) ; } void MdlInitializeSampleTimes ( void ) { ssSetSampleTime ( rtS , 0 , 0.0 ) ; ssSetSampleTime ( rtS , 1 , 0.0 ) ; ssSetSampleTime ( rtS , 2 , 1.0E-9 ) ; ssSetSampleTime ( rtS , 3 , 2.5E-5 ) ; ssSetSampleTime ( rtS , 4 , 5.0E-5 ) ; ssSetSampleTime ( rtS , 5 , 6.66E-5 ) ; ssSetOffsetTime ( rtS , 0 , 0.0 ) ; ssSetOffsetTime ( rtS , 1 , 1.0 ) ; ssSetOffsetTime ( rtS , 2 , 0.0 ) ; ssSetOffsetTime ( rtS , 3 , 0.0 ) ; ssSetOffsetTime ( rtS , 4 , 0.0 ) ; ssSetOffsetTime ( rtS , 5 , 0.0 ) ; } void raccel_set_checksum ( ) { ssSetChecksumVal ( rtS , 0 , 80411472U ) ; ssSetChecksumVal ( rtS , 1 , 2879298926U ) ; ssSetChecksumVal ( rtS , 2 , 547917316U ) ; ssSetChecksumVal ( rtS , 3 , 1663160932U ) ; }
#if defined(_MSC_VER)
#pragma optimize( "", off )
#endif
SimStruct * raccel_register_model ( ssExecutionInfo * executionInfo ) {
static struct _ssMdlInfo mdlInfo ; static struct _ssBlkInfo2 blkInfo2 ;
static struct _ssBlkInfoSLSize blkInfoSLSize ; rt_modelMapInfoPtr = & ( rt_dataMapInfo . mmi ) ; executionInfo -> gblObjects_ . numToFiles = 0 ; executionInfo -> gblObjects_ . numFrFiles = 0 ; executionInfo -> gblObjects_ . numFrWksBlocks = 0 ; executionInfo -> gblObjects_ . numModelInputs = 0 ; executionInfo -> gblObjects_ . numRootInportBlks = 0 ; executionInfo -> gblObjects_ . inportDataTypeIdx = NULL ; executionInfo -> gblObjects_ . inportDims = NULL ; executionInfo -> gblObjects_ . inportComplex = NULL ; executionInfo -> gblObjects_ . inportInterpoFlag = NULL ; executionInfo -> gblObjects_ . inportContinuous = NULL ; ( void ) memset ( ( char_T * ) rtS , 0 , sizeof ( SimStruct ) ) ; ( void ) memset ( ( char_T * ) & mdlInfo , 0 , sizeof ( struct _ssMdlInfo ) ) ; ( void ) memset ( ( char_T * ) & blkInfo2 , 0 , sizeof ( struct _ssBlkInfo2 ) ) ; ( void ) memset ( ( char_T * ) & blkInfoSLSize , 0 , sizeof ( struct _ssBlkInfoSLSize ) ) ; ssSetBlkInfo2Ptr ( rtS , & blkInfo2 ) ; ssSetBlkInfoSLSizePtr ( rtS , & blkInfoSLSize ) ; ssSetMdlInfoPtr ( rtS , & mdlInfo ) ; ssSetExecutionInfo ( rtS , executionInfo ) ; slsaAllocOPModelData ( rtS ) ; { static time_T mdlPeriod [ NSAMPLE_TIMES ] ; static time_T mdlOffset [ NSAMPLE_TIMES ] ; static time_T mdlTaskTimes [ NSAMPLE_TIMES ] ; static int_T mdlTsMap [ NSAMPLE_TIMES ] ; static int_T mdlSampleHits [ NSAMPLE_TIMES ] ; static boolean_T mdlTNextWasAdjustedPtr [ NSAMPLE_TIMES ] ; static int_T mdlPerTaskSampleHits [ NSAMPLE_TIMES * NSAMPLE_TIMES ] ; static time_T mdlTimeOfNextSampleHit [ NSAMPLE_TIMES ] ; { int_T i ; for ( i = 0 ; i < NSAMPLE_TIMES ; i ++ ) { mdlPeriod [ i ] = 0.0 ; mdlOffset [ i ] = 0.0 ; mdlTaskTimes [ i ] = 0.0 ; mdlTsMap [ i ] = i ; mdlSampleHits [ i ] = 1 ; } } ssSetSampleTimePtr ( rtS , & mdlPeriod [ 0 ] ) ; ssSetOffsetTimePtr ( rtS , & mdlOffset [ 0 ] ) ; ssSetSampleTimeTaskIDPtr ( rtS , & mdlTsMap [ 0 ] ) ; ssSetTPtr ( rtS , & mdlTaskTimes [ 0 ] ) ; ssSetSampleHitPtr ( rtS , & mdlSampleHits [ 0 ] ) ; ssSetTNextWasAdjustedPtr ( rtS , & mdlTNextWasAdjustedPtr [ 0 ] ) ; ssSetPerTaskSampleHitsPtr ( rtS , & mdlPerTaskSampleHits [ 0 ] ) ; ssSetTimeOfNextSampleHitPtr ( rtS , & mdlTimeOfNextSampleHit [ 0 ] ) ; } ssSetSolverMode ( rtS , SOLVER_MODE_SINGLETASKING ) ; { ssSetBlockIO ( rtS , ( ( void * ) & rtB ) ) ; ( void ) memset ( ( ( void * ) & rtB ) , 0 , sizeof ( B ) ) ; } { real_T * x = ( real_T * ) & rtX ; ssSetContStates ( rtS , x ) ; ( void ) memset ( ( void * ) x , 0 , sizeof ( X ) ) ; } { void * dwork = ( void * ) & rtDW ; ssSetRootDWork ( rtS , dwork ) ; ( void ) memset ( dwork , 0 , sizeof ( DW ) ) ; } { rtDW . pyuf5pxogp = 2 ; } { static DataTypeTransInfo dtInfo ; ( void ) memset ( ( char_T * ) & dtInfo , 0 , sizeof ( dtInfo ) ) ; ssSetModelMappingInfo ( rtS , & dtInfo ) ; dtInfo . numDataTypes = 25 ; dtInfo . dataTypeSizes = & rtDataTypeSizes [ 0 ] ; dtInfo . dataTypeNames = & rtDataTypeNames [ 0 ] ; dtInfo . BTransTable = & rtBTransTable ; dtInfo . PTransTable = & rtPTransTable ; dtInfo . dataTypeInfoTable = rtDataTypeInfoTable ; } svpwm_inv_ideal_switch_Motor_InitializeDataMapInfo ( ) ; ssSetIsRapidAcceleratorActive ( rtS , true ) ; ssSetRootSS ( rtS , rtS ) ; ssSetVersion ( rtS , SIMSTRUCT_VERSION_LEVEL2 ) ; ssSetModelName ( rtS , "svpwm_inv_ideal_switch_Motor" ) ; ssSetPath ( rtS , "svpwm_inv_ideal_switch_Motor" ) ; ssSetTStart ( rtS , 0.0 ) ; ssSetTFinal ( rtS , 0.5 ) ; { static RTWLogInfo rt_DataLoggingInfo ; rt_DataLoggingInfo . loggingInterval = ( NULL ) ; ssSetRTWLogInfo ( rtS , & rt_DataLoggingInfo ) ; } { { static int_T rt_LoggedStateWidths [ ] = { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 3 , 1 , 1 , 2 , 1 , 1 , 2 , 1 , 1 , 2 , 147 , 1 , 1 , 1 } ; static int_T rt_LoggedStateNumDimensions [ ] = { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 } ; static int_T rt_LoggedStateDimensions [ ] = { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 3 , 1 , 1 , 2 , 1 , 1 , 2 , 1 , 1 , 2 , 147 , 1 , 1 , 1 } ; static boolean_T rt_LoggedStateIsVarDims [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; static BuiltInDTypeId rt_LoggedStateDataTypeIds [ ] = { SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE , SS_DOUBLE } ; static int_T rt_LoggedStateComplexSignals [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; static RTWPreprocessingFcnPtr rt_LoggingStatePreprocessingFcnPtrs [ ] = { ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) } ; static const char_T * rt_LoggedStateLabels [ ] = { "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "CSTATE" , "Discrete_2934110732" , "FirstOutput_2934110732" , "DSTATE" , "DSTATE" , "DSTATE" , "Discrete_2474824636" , "DSTATE" , "DSTATE" , "Discrete_564268972" , "DSTATE" , "DSTATE" , "Discrete_3913449692" , "Discrete_2877237563" , "DSTATE" , "DSTATE" , "DSTATE" } ; static const char_T * rt_LoggedStateBlockNames [ ] = { "svpwm_inv_ideal_switch_Motor/Subsystem/Transfer Fcn" , "svpwm_inv_ideal_switch_Motor/Simulink-PS Converter1" , "svpwm_inv_ideal_switch_Motor/Inductor3" , "svpwm_inv_ideal_switch_Motor/Capacitor" , "svpwm_inv_ideal_switch_Motor/Inertia" , "svpwm_inv_ideal_switch_Motor/Ideal Rotational Motion Sensor" , "svpwm_inv_ideal_switch_Motor/PMSM" , "svpwm_inv_ideal_switch_Motor/PMSM" , "svpwm_inv_ideal_switch_Motor/PMSM" , "svpwm_inv_ideal_switch_Motor/Ideal Semiconductor Switch1" , "svpwm_inv_ideal_switch_Motor/Ideal Semiconductor Switch1" , "svpwm_inv_ideal_switch_Motor/Ideal Semiconductor Switch2" , "svpwm_inv_ideal_switch_Motor/Ideal Semiconductor Switch2" , "svpwm_inv_ideal_switch_Motor/Ideal Semiconductor Switch5" , "svpwm_inv_ideal_switch_Motor/Ideal Semiconductor Switch5" , "svpwm_inv_ideal_switch_Motor/Inductor3" , "svpwm_inv_ideal_switch_Motor/Half-Bridge Driver" , "svpwm_inv_ideal_switch_Motor/Half-Bridge Driver" , "svpwm_inv_ideal_switch_Motor/Half-Bridge Driver" , "svpwm_inv_ideal_switch_Motor/Half-Bridge Driver1" , "svpwm_inv_ideal_switch_Motor/Half-Bridge Driver1" , "svpwm_inv_ideal_switch_Motor/Half-Bridge Driver1" , "svpwm_inv_ideal_switch_Motor/Half-Bridge Driver2" , "svpwm_inv_ideal_switch_Motor/Half-Bridge Driver2" , "svpwm_inv_ideal_switch_Motor/Half-Bridge Driver2" , "svpwm_inv_ideal_switch_Motor/Ideal Semiconductor Switch1" , "svpwm_inv_ideal_switch_Motor/Ideal Semiconductor Switch2" , "svpwm_inv_ideal_switch_Motor/Ideal Semiconductor Switch3" , "svpwm_inv_ideal_switch_Motor/PMSM" , "svpwm_inv_ideal_switch_Motor/Ideal Semiconductor Switch3" , "svpwm_inv_ideal_switch_Motor/Ideal Semiconductor Switch4" , "svpwm_inv_ideal_switch_Motor/PMSM" , "svpwm_inv_ideal_switch_Motor/Ideal Semiconductor Switch4" , "svpwm_inv_ideal_switch_Motor/Ideal Semiconductor Switch5" , "svpwm_inv_ideal_switch_Motor/Ideal Semiconductor Switch6" , "svpwm_inv_ideal_switch_Motor/PMSM" , "svpwm_inv_ideal_switch_Motor/Ideal Semiconductor Switch6" , "svpwm_inv_ideal_switch_Motor/PMSM" , "svpwm_inv_ideal_switch_Motor/CurrentsMuxFilter/Transfer Fcn1" , "svpwm_inv_ideal_switch_Motor/CurrentsMuxFilter/Transfer Fcn2" , "svpwm_inv_ideal_switch_Motor/CurrentsMuxFilter/Transfer Fcn3" , "svpwm_inv_ideal_switch_Motor/CurrentsMuxFilter1/Mean2/Model/integrator" , "svpwm_inv_ideal_switch_Motor/CurrentsMuxFilter1/Mean1/Model/integrator" , "svpwm_inv_ideal_switch_Motor/CurrentsMuxFilter1/Mean/Model/integrator" , "svpwm_inv_ideal_switch_Motor/Transfer Fcn" , "svpwm_inv_ideal_switch_Motor/Simulink-PS Converter1" , "svpwm_inv_ideal_switch_Motor/Simulink-PS Converter1" , "svpwm_inv_ideal_switch_Motor/Unit Delay2" , "svpwm_inv_ideal_switch_Motor/PWM Generator1/Carrier counter/Integrator with\nWrapped State\n(Discrete or Continuous)/Discrete/Integrator" , "svpwm_inv_ideal_switch_Motor/PWM Generator1/Carrier counter/Integrator with\nWrapped State\n(Discrete or Continuous)1/Discrete/Integrator" , "svpwm_inv_ideal_switch_Motor/Simulink-PS Converter5" , "svpwm_inv_ideal_switch_Motor/PWM Generator2/Carrier counter/Integrator with\nWrapped State\n(Discrete or Continuous)/Discrete/Integrator" , "svpwm_inv_ideal_switch_Motor/PWM Generator2/Carrier counter/Integrator with\nWrapped State\n(Discrete or Continuous)1/Discrete/Integrator" , "svpwm_inv_ideal_switch_Motor/Simulink-PS Converter7" , "svpwm_inv_ideal_switch_Motor/PWM Generator/Carrier counter/Integrator with\nWrapped State\n(Discrete or Continuous)/Discrete/Integrator" , "svpwm_inv_ideal_switch_Motor/PWM Generator/Carrier counter/Integrator with\nWrapped State\n(Discrete or Continuous)1/Discrete/Integrator" , "svpwm_inv_ideal_switch_Motor/Simulink-PS Converter" , "svpwm_inv_ideal_switch_Motor/Solver Configuration1" , "svpwm_inv_ideal_switch_Motor/PID Controller2/Integrator/Discrete/Integrator" , "svpwm_inv_ideal_switch_Motor/Subsystem1/PID Controller3/Integrator/Discrete/Integrator" , "svpwm_inv_ideal_switch_Motor/Subsystem1/PID Controller4/Integrator/Discrete/Integrator" } ; static const char_T * rt_LoggedStateNames [ ] = { "" , "svpwm_inv_ideal_switch_Motor.Simulink_PS_Converter1.outputFiltered_3219448948_0" , "svpwm_inv_ideal_switch_Motor.Inductor3.i_L" , "svpwm_inv_ideal_switch_Motor.Capacitor.vc" , "svpwm_inv_ideal_switch_Motor.Inertia.w" , "svpwm_inv_ideal_switch_Motor.Ideal_Rotational_Motion_Sensor.phi" , "svpwm_inv_ideal_switch_Motor.PMSM.angular_position" , "svpwm_inv_ideal_switch_Motor.PMSM.i_d" , "svpwm_inv_ideal_switch_Motor.PMSM.i_q" , "svpwm_inv_ideal_switch_Motor.Ideal_Semiconductor_Switch1.diode.i_diode" , "svpwm_inv_ideal_switch_Motor.Ideal_Semiconductor_Switch1.ideal_switch.i" , "svpwm_inv_ideal_switch_Motor.Ideal_Semiconductor_Switch2.diode.i_diode" , "svpwm_inv_ideal_switch_Motor.Ideal_Semiconductor_Switch2.ideal_switch.i" , "svpwm_inv_ideal_switch_Motor.Ideal_Semiconductor_Switch5.diode.i_diode" , "svpwm_inv_ideal_switch_Motor.Ideal_Semiconductor_Switch5.ideal_switch.i" , "svpwm_inv_ideal_switch_Motor.Inductor3.v" , "svpwm_inv_ideal_switch_Motor.Half_Bridge_Driver.HO.v" , "svpwm_inv_ideal_switch_Motor.Half_Bridge_Driver.HS.v" , "svpwm_inv_ideal_switch_Motor.Half_Bridge_Driver.LO.v" , "svpwm_inv_ideal_switch_Motor.Half_Bridge_Driver1.HO.v" , "svpwm_inv_ideal_switch_Motor.Half_Bridge_Driver1.HS.v" , "svpwm_inv_ideal_switch_Motor.Half_Bridge_Driver1.LO.v" , "svpwm_inv_ideal_switch_Motor.Half_Bridge_Driver2.HO.v" , "svpwm_inv_ideal_switch_Motor.Half_Bridge_Driver2.HS.v" , "svpwm_inv_ideal_switch_Motor.Half_Bridge_Driver2.LO.v" , "svpwm_inv_ideal_switch_Motor.Ideal_Semiconductor_Switch1.diode.private.Diode.threshold" , "svpwm_inv_ideal_switch_Motor.Ideal_Semiconductor_Switch2.diode.private.Diode.threshold" , "svpwm_inv_ideal_switch_Motor.Ideal_Semiconductor_Switch3.ideal_switch.i" , "svpwm_inv_ideal_switch_Motor.PMSM.i_a" , "svpwm_inv_ideal_switch_Motor.Ideal_Semiconductor_Switch3.diode.private.Diode.threshold" , "svpwm_inv_ideal_switch_Motor.Ideal_Semiconductor_Switch4.ideal_switch.i" , "svpwm_inv_ideal_switch_Motor.PMSM.i_b" , "svpwm_inv_ideal_switch_Motor.Ideal_Semiconductor_Switch4.diode.private.Diode.threshold" , "svpwm_inv_ideal_switch_Motor.Ideal_Semiconductor_Switch5.diode.private.Diode.threshold" , "svpwm_inv_ideal_switch_Motor.Ideal_Semiconductor_Switch6.ideal_switch.i" , "svpwm_inv_ideal_switch_Motor.PMSM.i_c" , "svpwm_inv_ideal_switch_Motor.Ideal_Semiconductor_Switch6.diode.private.Diode.threshold" , "svpwm_inv_ideal_switch_Motor.PMSM.torque" , "" , "" , "" , "" , "" , "" , "" , "Discrete_2934110732" , "FirstOutput_2934110732" , "DSTATE" , "DSTATE" , "DSTATE" , "Discrete_2474824636" , "DSTATE" , "DSTATE" , "Discrete_564268972" , "DSTATE" , "DSTATE" , "Discrete_3913449692" , "Discrete_2877237563" , "DSTATE" , "DSTATE" , "DSTATE" } ; static boolean_T rt_LoggedStateCrossMdlRef [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; static RTWLogDataTypeConvert rt_RTWLogDataTypeConvert [ ] = { { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } } ; static int_T rt_LoggedStateIdxList [ ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 } ; static RTWLogSignalInfo rt_LoggedStateSignalInfo = { 61 , rt_LoggedStateWidths , rt_LoggedStateNumDimensions , rt_LoggedStateDimensions , rt_LoggedStateIsVarDims , ( NULL ) , ( NULL ) , rt_LoggedStateDataTypeIds , rt_LoggedStateComplexSignals , ( NULL ) , rt_LoggingStatePreprocessingFcnPtrs , { rt_LoggedStateLabels } , ( NULL ) , ( NULL ) , ( NULL ) , { rt_LoggedStateBlockNames } , { rt_LoggedStateNames } , rt_LoggedStateCrossMdlRef , rt_RTWLogDataTypeConvert , rt_LoggedStateIdxList } ; static void * rt_LoggedStateSignalPtrs [ 61 ] ; rtliSetLogXSignalPtrs ( ssGetRTWLogInfo ( rtS ) , ( LogSignalPtrsType ) rt_LoggedStateSignalPtrs ) ; rtliSetLogXSignalInfo ( ssGetRTWLogInfo ( rtS ) , & rt_LoggedStateSignalInfo ) ; rt_LoggedStateSignalPtrs [ 0 ] = ( void * ) & rtX . mmcyaey4zw ; rt_LoggedStateSignalPtrs [ 1 ] = ( void * ) & rtX . erjd0mhsiq ; rt_LoggedStateSignalPtrs [ 2 ] = ( void * ) & rtX . mmg5sph3io [ 0 ] ; rt_LoggedStateSignalPtrs [ 3 ] = ( void * ) & rtX . mmg5sph3io [ 1 ] ; rt_LoggedStateSignalPtrs [ 4 ] = ( void * ) & rtX . mmg5sph3io [ 2 ] ; rt_LoggedStateSignalPtrs [ 5 ] = ( void * ) & rtX . mmg5sph3io [ 3 ] ; rt_LoggedStateSignalPtrs [ 6 ] = ( void * ) & rtX . mmg5sph3io [ 4 ] ; rt_LoggedStateSignalPtrs [ 7 ] = ( void * ) & rtX . mmg5sph3io [ 5 ] ; rt_LoggedStateSignalPtrs [ 8 ] = ( void * ) & rtX . mmg5sph3io [ 6 ] ; rt_LoggedStateSignalPtrs [ 9 ] = ( void * ) & rtX . mmg5sph3io [ 7 ] ; rt_LoggedStateSignalPtrs [ 10 ] = ( void * ) & rtX . mmg5sph3io [ 8 ] ; rt_LoggedStateSignalPtrs [ 11 ] = ( void * ) & rtX . mmg5sph3io [ 9 ] ; rt_LoggedStateSignalPtrs [ 12 ] = ( void * ) & rtX . mmg5sph3io [ 10 ] ; rt_LoggedStateSignalPtrs [ 13 ] = ( void * ) & rtX . mmg5sph3io [ 11 ] ; rt_LoggedStateSignalPtrs [ 14 ] = ( void * ) & rtX . mmg5sph3io [ 12 ] ; rt_LoggedStateSignalPtrs [ 15 ] = ( void * ) & rtX . mmg5sph3io [ 13 ] ; rt_LoggedStateSignalPtrs [ 16 ] = ( void * ) & rtX . mmg5sph3io [ 14 ] ; rt_LoggedStateSignalPtrs [ 17 ] = ( void * ) & rtX . mmg5sph3io [ 15 ] ; rt_LoggedStateSignalPtrs [ 18 ] = ( void * ) & rtX . mmg5sph3io [ 16 ] ; rt_LoggedStateSignalPtrs [ 19 ] = ( void * ) & rtX . mmg5sph3io [ 17 ] ; rt_LoggedStateSignalPtrs [ 20 ] = ( void * ) & rtX . mmg5sph3io [ 18 ] ; rt_LoggedStateSignalPtrs [ 21 ] = ( void * ) & rtX . mmg5sph3io [ 19 ] ; rt_LoggedStateSignalPtrs [ 22 ] = ( void * ) & rtX . mmg5sph3io [ 20 ] ; rt_LoggedStateSignalPtrs [ 23 ] = ( void * ) & rtX . mmg5sph3io [ 21 ] ; rt_LoggedStateSignalPtrs [ 24 ] = ( void * ) & rtX . mmg5sph3io [ 22 ] ; rt_LoggedStateSignalPtrs [ 25 ] = ( void * ) & rtX . mmg5sph3io [ 23 ] ; rt_LoggedStateSignalPtrs [ 26 ] = ( void * ) & rtX . mmg5sph3io [ 24 ] ; rt_LoggedStateSignalPtrs [ 27 ] = ( void * ) & rtX . mmg5sph3io [ 25 ] ; rt_LoggedStateSignalPtrs [ 28 ] = ( void * ) & rtX . mmg5sph3io [ 26 ] ; rt_LoggedStateSignalPtrs [ 29 ] = ( void * ) & rtX . mmg5sph3io [ 27 ] ; rt_LoggedStateSignalPtrs [ 30 ] = ( void * ) & rtX . mmg5sph3io [ 28 ] ; rt_LoggedStateSignalPtrs [ 31 ] = ( void * ) & rtX . mmg5sph3io [ 29 ] ; rt_LoggedStateSignalPtrs [ 32 ] = ( void * ) & rtX . mmg5sph3io [ 30 ] ; rt_LoggedStateSignalPtrs [ 33 ] = ( void * ) & rtX . mmg5sph3io [ 31 ] ; rt_LoggedStateSignalPtrs [ 34 ] = ( void * ) & rtX . mmg5sph3io [ 32 ] ; rt_LoggedStateSignalPtrs [ 35 ] = ( void * ) & rtX . mmg5sph3io [ 33 ] ; rt_LoggedStateSignalPtrs [ 36 ] = ( void * ) & rtX . mmg5sph3io [ 34 ] ; rt_LoggedStateSignalPtrs [ 37 ] = ( void * ) & rtX . mmg5sph3io [ 35 ] ; rt_LoggedStateSignalPtrs [ 38 ] = ( void * ) & rtX . lqcuiwaata ; rt_LoggedStateSignalPtrs [ 39 ] = ( void * ) & rtX . fqujvrhmxc ; rt_LoggedStateSignalPtrs [ 40 ] = ( void * ) & rtX . lvqvgep4z3 ; rt_LoggedStateSignalPtrs [ 41 ] = ( void * ) & rtX . c1dvebixah ; rt_LoggedStateSignalPtrs [ 42 ] = ( void * ) & rtX . bufufyp5jw ; rt_LoggedStateSignalPtrs [ 43 ] = ( void * ) & rtX . nrr4jufios ; rt_LoggedStateSignalPtrs [ 44 ] = ( void * ) & rtX . adzjcfmnhs ; rt_LoggedStateSignalPtrs [ 45 ] = ( void * ) & rtDW . p2newwshb2 ; rt_LoggedStateSignalPtrs [ 46 ] = ( void * ) & rtDW . p1eaxc4si3 ; rt_LoggedStateSignalPtrs [ 47 ] = ( void * ) rtDW . fvjpifmnqp ; rt_LoggedStateSignalPtrs [ 48 ] = ( void * ) & rtDW . afz1wmfwwl ; rt_LoggedStateSignalPtrs [ 49 ] = ( void * ) & rtDW . l311fk1wdw ; rt_LoggedStateSignalPtrs [ 50 ] = ( void * ) rtDW . lvtmdk5pzk ; rt_LoggedStateSignalPtrs [ 51 ] = ( void * ) & rtDW . okewh4umdj ; rt_LoggedStateSignalPtrs [ 52 ] = ( void * ) & rtDW . pzb0hgihqm ; rt_LoggedStateSignalPtrs [ 53 ] = ( void * ) rtDW . kr2nbusf3i ; rt_LoggedStateSignalPtrs [ 54 ] = ( void * ) & rtDW . liqja2sob3 ; rt_LoggedStateSignalPtrs [ 55 ] = ( void * ) & rtDW . inzd25bki4 ; rt_LoggedStateSignalPtrs [ 56 ] = ( void * ) rtDW . hz3nw5alev ; rt_LoggedStateSignalPtrs [ 57 ] = ( void * ) rtDW . atond0rmxa ; rt_LoggedStateSignalPtrs [ 58 ] = ( void * ) & rtDW . myxkp4g3jb ; rt_LoggedStateSignalPtrs [ 59 ] = ( void * ) & rtDW . gcyhq2afeb ; rt_LoggedStateSignalPtrs [ 60 ] = ( void * ) & rtDW . p4cmclm0n5 ; } rtliSetLogT ( ssGetRTWLogInfo ( rtS ) , "tout" ) ; rtliSetLogX ( ssGetRTWLogInfo ( rtS ) , "" ) ; rtliSetLogXFinal ( ssGetRTWLogInfo ( rtS ) , "xFinal" ) ; rtliSetLogVarNameModifier ( ssGetRTWLogInfo ( rtS ) , "none" ) ; rtliSetLogFormat ( ssGetRTWLogInfo ( rtS ) , 4 ) ; rtliSetLogMaxRows ( ssGetRTWLogInfo ( rtS ) , 0 ) ; rtliSetLogDecimation ( ssGetRTWLogInfo ( rtS ) , 1 ) ; rtliSetLogY ( ssGetRTWLogInfo ( rtS ) , "" ) ; rtliSetLogYSignalInfo ( ssGetRTWLogInfo ( rtS ) , ( NULL ) ) ; rtliSetLogYSignalPtrs ( ssGetRTWLogInfo ( rtS ) , ( NULL ) ) ; } { static struct _ssStatesInfo2 statesInfo2 ; ssSetStatesInfo2 ( rtS , & statesInfo2 ) ; } { static ssPeriodicStatesInfo periodicStatesInfo ; ssSetPeriodicStatesInfo ( rtS , & periodicStatesInfo ) ; } { static ssJacobianPerturbationBounds jacobianPerturbationBounds ; ssSetJacobianPerturbationBounds ( rtS , & jacobianPerturbationBounds ) ; } { static ssSolverInfo slvrInfo ; static struct _ssSFcnModelMethods3 mdlMethods3 ; static struct _ssSFcnModelMethods2 mdlMethods2 ; static boolean_T contStatesDisabled [ 45 ] ; static real_T absTol [ 45 ] = { 1.0E-6 , 1.0E-6 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 0.001 , 1.0E-6 , 1.0E-6 , 1.0E-6 , 1.0E-6 , 1.0E-6 , 1.0E-6 , 1.0E-6 } ; static uint8_T absTolControl [ 45 ] = { 0U , 0U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 2U , 0U , 0U , 0U , 0U , 0U , 0U , 0U } ; static real_T contStateJacPerturbBoundMinVec [ 45 ] ; static real_T contStateJacPerturbBoundMaxVec [ 45 ] ; static uint8_T zcAttributes [ 62 ] = { ( ZC_EVENT_ALL ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( 0x80 | ZC_EVENT_P2Z | ZC_EVENT_P2N | ZC_EVENT_Z2P | ZC_EVENT_N2P ) , ( ZC_EVENT_ALL ) , ( ZC_EVENT_ALL ) , ( ZC_EVENT_ALL ) , ( ZC_EVENT_ALL_UP ) , ( ZC_EVENT_ALL_UP ) } ; static ssNonContDerivSigInfo nonContDerivSigInfo [ 5 ] = { { 1 * sizeof ( real_T ) , ( char * ) ( & rtB . iyki3ean2s ) , ( NULL ) } , { 1 * sizeof ( real_T ) , ( char * ) ( & rtB . kqiarrulir ) , ( NULL ) } , { 1 * sizeof ( real_T ) , ( char * ) ( & rtB . nhbuwczelb ) , ( NULL ) } , { 1 * sizeof ( real_T ) , ( char * ) ( & rtB . ez3qw0cmbe ) , ( NULL ) } , { 1 * sizeof ( real_T ) , ( char * ) ( & rtB . nvyiuv1zxl ) , ( NULL ) } } ; { int i ; for ( i = 0 ; i < 45 ; ++ i ) { contStateJacPerturbBoundMinVec [ i ] = 0 ; contStateJacPerturbBoundMaxVec [ i ] = rtGetInf ( ) ; } } ssSetSolverRelTol ( rtS , 0.001 ) ; ssSetStepSize ( rtS , 0.0 ) ; ssSetMinStepSize ( rtS , 0.0 ) ; ssSetMaxNumMinSteps ( rtS , - 1 ) ; ssSetMinStepViolatedError ( rtS , 0 ) ; ssSetMaxStepSize ( rtS , 1.0E-9 ) ; ssSetSolverMaxOrder ( rtS , - 1 ) ; ssSetSolverRefineFactor ( rtS , 1 ) ; ssSetOutputTimes ( rtS , ( NULL ) ) ; ssSetNumOutputTimes ( rtS , 0 ) ; ssSetOutputTimesOnly ( rtS , 0 ) ; ssSetOutputTimesIndex ( rtS , 0 ) ; ssSetZCCacheNeedsReset ( rtS , 1 ) ; ssSetDerivCacheNeedsReset ( rtS , 0 ) ; ssSetNumNonContDerivSigInfos ( rtS , 5 ) ; ssSetNonContDerivSigInfos ( rtS , nonContDerivSigInfo ) ; ssSetSolverInfo ( rtS , & slvrInfo ) ; ssSetSolverName ( rtS , "daessc" ) ; ssSetVariableStepSolver ( rtS , 1 ) ; ssSetSolverConsistencyChecking ( rtS , 0 ) ; ssSetSolverAdaptiveZcDetection ( rtS , 1 ) ; ssSetSolverRobustResetMethod ( rtS , 0 ) ; _ssSetSolverUpdateJacobianAtReset ( rtS , true ) ; ssSetAbsTolVector ( rtS , absTol ) ; ssSetAbsTolControlVector ( rtS , absTolControl ) ; ssSetSolverAbsTol_Obsolete ( rtS , absTol ) ; ssSetSolverAbsTolControl_Obsolete ( rtS , absTolControl ) ; ssSetJacobianPerturbationBoundsMinVec ( rtS , contStateJacPerturbBoundMinVec ) ; ssSetJacobianPerturbationBoundsMaxVec ( rtS , contStateJacPerturbBoundMaxVec ) ; ssSetSolverStateProjection ( rtS , 0 ) ; ( void ) memset ( ( void * ) & mdlMethods2 , 0 , sizeof ( mdlMethods2 ) ) ; ssSetModelMethods2 ( rtS , & mdlMethods2 ) ; ( void ) memset ( ( void * ) & mdlMethods3 , 0 , sizeof ( mdlMethods3 ) ) ; ssSetModelMethods3 ( rtS , & mdlMethods3 ) ; ssSetMassMatrixType ( rtS , ( ssMatrixType ) 1 ) ; ssSetMassMatrixNzMax ( rtS , 16 ) ; ssSetModelMassMatrix ( rtS , MdlMassMatrix ) ; ssSetModelForcingFunction ( rtS , MdlForcingFunction ) ; ssSetSolverMassMatrixType ( rtS , ( ssMatrixType ) 1 ) ; ssSetSolverMassMatrixNzMax ( rtS , 16 ) ; ssSetModelOutputs ( rtS , MdlOutputs ) ; ssSetModelUpdate ( rtS , MdlUpdate ) ; ssSetModelDerivatives ( rtS , MdlDerivatives ) ; ssSetSolverZcSignalAttrib ( rtS , zcAttributes ) ; ssSetSolverNumZcSignals ( rtS , 62 ) ; ssSetModelZeroCrossings ( rtS , MdlZeroCrossings ) ; ssSetSolverConsecutiveZCsStepRelTol ( rtS , 2.8421709430404007E-13 ) ; ssSetSolverMaxConsecutiveZCs ( rtS , 1000 ) ; ssSetSolverConsecutiveZCsError ( rtS , 2 ) ; ssSetSolverMaskedZcDiagnostic ( rtS , 1 ) ; ssSetSolverIgnoredZcDiagnostic ( rtS , 0 ) ; ssSetSolverZcThreshold ( rtS , 0.001 ) ; ssSetSolverMaxConsecutiveMinStep ( rtS , 1 ) ; ssSetSolverShapePreserveControl ( rtS , 2 ) ; ssSetTNextTid ( rtS , INT_MIN ) ; ssSetTNext ( rtS , rtMinusInf ) ; ssSetSolverNeedsReset ( rtS ) ; ssSetNumNonsampledZCs ( rtS , 62 ) ; ssSetContStateDisabled ( rtS , contStatesDisabled ) ; ssSetSolverMaxConsecutiveMinStep ( rtS , 1 ) ; { int_T * ir = rtMassMatrix . ir ; int_T * jc = rtMassMatrix . jc ; real_T * pr = rtMassMatrix . pr ; ssSetMassMatrixIr ( rtS , ir ) ; ssSetMassMatrixJc ( rtS , jc ) ; ssSetMassMatrixPr ( rtS , pr ) ; ( void ) memset ( ( void * ) ir , 0 , 16 * sizeof ( int_T ) ) ; ( void ) memset ( ( void * ) jc , 0 , ( 45 + 1 ) * sizeof ( int_T ) ) ; ( void ) memset ( ( void * ) pr , 0 , 16 * sizeof ( real_T ) ) ; } } { ZCSigState * zc = ( ZCSigState * ) & rtPrevZCX ; ssSetPrevZCSigState ( rtS , zc ) ; } { rtPrevZCX . epxdgu0lml = UNINITIALIZED_ZCSIG ; rtPrevZCX . l32ag3g4ya = UNINITIALIZED_ZCSIG ; rtPrevZCX . dtmkoleoq1 = UNINITIALIZED_ZCSIG ; rtPrevZCX . isscwtbkju = UNINITIALIZED_ZCSIG ; rtPrevZCX . g5zjqphypq = UNINITIALIZED_ZCSIG ; rtPrevZCX . aqhboz3swy = UNINITIALIZED_ZCSIG ; rtPrevZCX . guwnkcn12w = UNINITIALIZED_ZCSIG ; rtPrevZCX . g3i20wjvur = UNINITIALIZED_ZCSIG ; rtPrevZCX . mwdvgkbxlo = UNINITIALIZED_ZCSIG ; rtPrevZCX . gzliyyj43f = UNINITIALIZED_ZCSIG ; rtPrevZCX . o5000kjfdl = UNINITIALIZED_ZCSIG ; rtPrevZCX . nxd5me1bxv = UNINITIALIZED_ZCSIG ; rtPrevZCX . eiwztgfplc = UNINITIALIZED_ZCSIG ; rtPrevZCX . gau1y0jr5q = UNINITIALIZED_ZCSIG ; rtPrevZCX . ng4v0y2nhq = UNINITIALIZED_ZCSIG ; rtPrevZCX . kxbgnvzvjn = UNINITIALIZED_ZCSIG ; rtPrevZCX . jaqxyayzdc = UNINITIALIZED_ZCSIG ; rtPrevZCX . ksylrzpxif = UNINITIALIZED_ZCSIG ; rtPrevZCX . crxkm0hxys = UNINITIALIZED_ZCSIG ; rtPrevZCX . botrwlhyuk = UNINITIALIZED_ZCSIG ; rtPrevZCX . kgqcetg5ig = UNINITIALIZED_ZCSIG ; rtPrevZCX . ajtrlgwqgm = UNINITIALIZED_ZCSIG ; rtPrevZCX . begh5ldxew = UNINITIALIZED_ZCSIG ; rtPrevZCX . ddarzhcive = UNINITIALIZED_ZCSIG ; rtPrevZCX . jlrxkok5nf = UNINITIALIZED_ZCSIG ; rtPrevZCX . octpgtqm4z = UNINITIALIZED_ZCSIG ; rtPrevZCX . one4k0q4ck = UNINITIALIZED_ZCSIG ; rtPrevZCX . kh412igkys = UNINITIALIZED_ZCSIG ; rtPrevZCX . clczoywdxa = UNINITIALIZED_ZCSIG ; rtPrevZCX . ndnz1ep2x0 = UNINITIALIZED_ZCSIG ; rtPrevZCX . iezpy55kce = UNINITIALIZED_ZCSIG ; rtPrevZCX . msvp3buwwc = UNINITIALIZED_ZCSIG ; rtPrevZCX . aqqrz43dyl = UNINITIALIZED_ZCSIG ; rtPrevZCX . bldbnfsxnj = UNINITIALIZED_ZCSIG ; rtPrevZCX . dl4yrcsqwy = UNINITIALIZED_ZCSIG ; rtPrevZCX . kwtm2ouoy5 = UNINITIALIZED_ZCSIG ; rtPrevZCX . eslqbm1lij = UNINITIALIZED_ZCSIG ; rtPrevZCX . itugyvxwu2 = UNINITIALIZED_ZCSIG ; rtPrevZCX . njf2grmgps = UNINITIALIZED_ZCSIG ; rtPrevZCX . gsd02gvnh1 = UNINITIALIZED_ZCSIG ; rtPrevZCX . bkn4mrnvcm = UNINITIALIZED_ZCSIG ; rtPrevZCX . dbzdx4ebmb = UNINITIALIZED_ZCSIG ; rtPrevZCX . fmmj3tn1io = UNINITIALIZED_ZCSIG ; rtPrevZCX . jafv1z3ehc = UNINITIALIZED_ZCSIG ; rtPrevZCX . l02h2rlrqo = UNINITIALIZED_ZCSIG ; rtPrevZCX . pkp12er1x1 = UNINITIALIZED_ZCSIG ; rtPrevZCX . bjimnz4cgu = UNINITIALIZED_ZCSIG ; rtPrevZCX . luuvnlz5hm = UNINITIALIZED_ZCSIG ; rtPrevZCX . nndsjwtomb = UNINITIALIZED_ZCSIG ; rtPrevZCX . g1yry2oia3 = UNINITIALIZED_ZCSIG ; rtPrevZCX . evwfnmin0u = UNINITIALIZED_ZCSIG ; rtPrevZCX . ke0pamss4f = UNINITIALIZED_ZCSIG ; rtPrevZCX . iphgsg1jzj = UNINITIALIZED_ZCSIG ; rtPrevZCX . ogsy4dyqtg = UNINITIALIZED_ZCSIG ; rtPrevZCX . n04d0fmoar = UNINITIALIZED_ZCSIG ; rtPrevZCX . nyihggaq3b = UNINITIALIZED_ZCSIG ; } ssSetChecksumVal ( rtS , 0 , 80411472U ) ; ssSetChecksumVal ( rtS , 1 , 2879298926U ) ; ssSetChecksumVal ( rtS , 2 , 547917316U ) ; ssSetChecksumVal ( rtS , 3 , 1663160932U ) ; { static const sysRanDType rtAlwaysEnabled = SUBSYS_RAN_BC_ENABLE ; static RTWExtModeInfo rt_ExtModeInfo ; static const sysRanDType * systemRan [ 19 ] ; gblRTWExtModeInfo = & rt_ExtModeInfo ; ssSetRTWExtModeInfo ( rtS , & rt_ExtModeInfo ) ; rteiSetSubSystemActiveVectorAddresses ( & rt_ExtModeInfo , systemRan ) ; systemRan [ 0 ] = & rtAlwaysEnabled ; systemRan [ 1 ] = & rtAlwaysEnabled ; systemRan [ 2 ] = & rtAlwaysEnabled ; systemRan [ 3 ] = & rtAlwaysEnabled ; systemRan [ 4 ] = & rtAlwaysEnabled ; systemRan [ 5 ] = & rtAlwaysEnabled ; systemRan [ 6 ] = & rtAlwaysEnabled ; systemRan [ 7 ] = & rtAlwaysEnabled ; systemRan [ 8 ] = & rtAlwaysEnabled ; systemRan [ 9 ] = & rtAlwaysEnabled ; systemRan [ 10 ] = & rtAlwaysEnabled ; systemRan [ 11 ] = & rtAlwaysEnabled ; systemRan [ 12 ] = & rtAlwaysEnabled ; systemRan [ 13 ] = & rtAlwaysEnabled ; systemRan [ 14 ] = & rtAlwaysEnabled ; systemRan [ 15 ] = & rtAlwaysEnabled ; systemRan [ 16 ] = & rtAlwaysEnabled ; systemRan [ 17 ] = & rtAlwaysEnabled ; systemRan [ 18 ] = & rtAlwaysEnabled ; rteiSetModelMappingInfoPtr ( ssGetRTWExtModeInfo ( rtS ) , & ssGetModelMappingInfo ( rtS ) ) ; rteiSetChecksumsPtr ( ssGetRTWExtModeInfo ( rtS ) , ssGetChecksums ( rtS ) ) ; rteiSetTPtr ( ssGetRTWExtModeInfo ( rtS ) , ssGetTPtr ( rtS ) ) ; } slsaDisallowedBlocksForSimTargetOP ( rtS , mr_svpwm_inv_ideal_switch_Motor_GetSimStateDisallowedBlocks ) ; slsaGetWorkFcnForSimTargetOP ( rtS , mr_svpwm_inv_ideal_switch_Motor_GetDWork ) ; slsaSetWorkFcnForSimTargetOP ( rtS , mr_svpwm_inv_ideal_switch_Motor_SetDWork ) ; rt_RapidReadMatFileAndUpdateParams ( rtS ) ; if ( ssGetErrorStatus ( rtS ) ) { return rtS ; } executionInfo -> simulationOptions_ . stateSaveName_ = rtliGetLogX ( ssGetRTWLogInfo ( rtS ) ) ; executionInfo -> simulationOptions_ . finalStateName_ = rtliGetLogXFinal ( ssGetRTWLogInfo ( rtS ) ) ; executionInfo -> simulationOptions_ . outputSaveName_ = rtliGetLogY ( ssGetRTWLogInfo ( rtS ) ) ; executionInfo -> simulationOptions_ . inputTimeTolerance_ = 0.0 ; return rtS ; }
#if defined(_MSC_VER)
#pragma optimize( "", on )
#endif
void MdlOutputsParameterSampleTime ( int_T tid ) { MdlOutputsTID6 ( tid ) ; }
